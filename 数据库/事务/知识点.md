# 知识点

## 不可重复读和幻读区别

- 不可重复读：同一条记录的**值**变化（更新）
- 幻读：**行数**变化（新增或删除）

不可重复读：读取了其它事务更改的数据，针对update操作

- 解决：使用行级锁，锁定该行数据，事务A多次读取完后才释放锁，这时才允许其它事务更改。

幻读：读取了其它事务新增/删除的数据，针对insert和delete操作

- 解决：使用表级锁，锁定整张表，事务A多次读取后才释放锁，这时才允许其它事务新增/删除数据。

## MySQL 隐式与显式锁定

### 隐式锁定

MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要时自动加锁（X/S），并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。

### 显示锁定

InnoDB 也可以使用特定的语句进行显示锁定：

- 共享锁：`SELECT ... LOCK In SHARE MODE;`
- 互斥锁：`SELECT ... FOR UPDATE;`

## MVCC

### Q1：MVCC会导致数据不一致吗？

```sql
-- 不会，MVCC通过版本控制保证一致性
-- 示例：银行转账

-- 事务A
BEGIN;
SELECT balance FROM accounts WHERE id = 1; -- 快照读：1000
-- 基于1000做业务逻辑...

-- 事务B同时更新
UPDATE accounts SET balance = 900 WHERE id = 1;
COMMIT;

-- 事务A继续
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
-- 这里会看到最新值900，更新为800
-- 没有丢失更新，保证一致性
COMMIT;
```

### Q2：MVCC如何处理幻读？

```sql
-- MySQL InnoDB的可重复读+MVCC
BEGIN;
-- 获取快照
SELECT * FROM orders WHERE amount > 1000; -- 返回3行

-- 其他事务插入新订单并提交
INSERT INTO orders (amount) VALUES (2000);

-- 再次查询
SELECT * FROM orders WHERE amount > 1000; -- 仍返回3行（快照读）
-- 但如果是当前读：
SELECT * FROM orders WHERE amount > 1000 FOR UPDATE;
-- 可能看到4行（幻读），所以InnoDB使用Next-Key Lock
```

### Q3：什么时候选择MVCC vs 传统锁？

```
选择MVCC当：
- 读多写少
- 需要高并发读写
- 可以接受一定存储开销
- 需要时间点查询

选择传统锁当：
- 写多读少
- 存储空间敏感
- 简单并发控制足够
- 实时强一致性要求
```

## 封锁和MVCC

- 封锁通过加锁能解决多个事务同时执行时出现的并发一致性问题，例如读和读不互斥关系，读写锁中读和写操作仍然是互斥的。

- MVCC是一种多版本并发控制的方法，用更好的方式去处理读-写冲突，写写冲突通过加悲观锁和乐观锁实现。