# 事务隔离

**事务隔离**——这是数据库并发控制的核心机制。

| 隔离级别 | 脏读   | 不可重复读 | 幻读   | 性能影响 | 典型默认设置               |
| -------- | ------ | ---------- | ------ | -------- | -------------------------- |
| 读未提交 | ❌ 允许 | ❌ 允许     | ❌ 允许 | 最低     | SQL Server（默认）         |
| 读已提交 | ✅ 防止 | ❌ 允许     | ❌ 允许 | 低       | PostgreSQL, Oracle（默认） |
| 可重复读 | ✅ 防止 | ✅ 防止     | ❌ 允许 | 中       | MySQL（InnoDB默认）        |
| 串行化   | ✅ 防止 | ✅ 防止     | ✅ 防止 | 高       | 需显式指定                 |

## 一、核心定义

**事务隔离**是指数据库管理系统控制**多个并发事务**之间的相互影响程度的机制。它决定了：
- 一个事务能看到其他事务的哪些修改
- 不同事务之间的操作如何相互影响
- 在并发环境下如何保证数据一致性

## 二、为什么需要事务隔离？

### 没有隔离的问题场景：
```sql
-- 两个用户同时预订最后一间房
-- 初始：房间数 rooms_available = 1

-- 用户A的会话
BEGIN;
SELECT rooms_available FROM hotel WHERE id = 1; -- 看到1

-- 用户B的会话  
BEGIN;
SELECT rooms_available FROM hotel WHERE id = 1; -- 也看到1

-- 用户A预订
UPDATE hotel SET rooms_available = 0 WHERE id = 1;
COMMIT; -- 成功预订

-- 用户B也"成功"预订（实际上房间已无）
UPDATE hotel SET rooms_available = -1 WHERE id = 1;
COMMIT; -- 出现负库存！
```

**隔离的目的就是防止这种并发异常**。

## 三、SQL标准隔离级别

SQL标准定义了4个隔离级别，从宽松到严格：

### 1. **READ UNCOMMITTED（读未提交）**
最低级别隔离，几乎不提供隔离。

**特点**：
- 允许读取其他事务未提交的数据（脏读）
- 性能最高，一致性最差

```sql
-- 事务A
BEGIN TRANSACTION;
UPDATE accounts SET balance = 500 WHERE id = 1;
-- 未提交！

-- 事务B（读未提交级别）
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
BEGIN TRANSACTION;
SELECT balance FROM accounts WHERE id = 1; -- 看到500（脏读）
-- 事务A回滚了，但事务B以为余额是500
```

**适用场景**：
- 数据分析、统计报表（可容忍脏数据）
- 实时监控大屏
- 对准确性要求不高的场景

### 2. **READ COMMITTED（读已提交）**
大多数数据库的默认级别。

**特点**：
- 只能读取**已提交**的数据
- 防止脏读
- 允许不可重复读和幻读

```sql
-- 事务A
BEGIN;
SELECT balance FROM accounts WHERE id = 1; -- 返回1000

-- 事务B更新并提交
UPDATE accounts SET balance = 900 WHERE id = 1;
COMMIT;

-- 事务A再次读取
SELECT balance FROM accounts WHERE id = 1; -- 返回900
-- 两次读取结果不同（不可重复读）
COMMIT;
```

**实现机制**：
- **Oracle**：使用回滚段的多版本读
- **PostgreSQL、MySQL**：MVCC（每行有创建和删除版本号）
- **SQL Server**：行版本控制

### 3. **REPEATABLE READ（可重复读）**
保证同一事务内多次读取结果一致。

**特点**：
- 防止脏读和不可重复读
- 可能允许幻读
- MySQL InnoDB默认级别

```sql
-- 事务A（可重复读级别）
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
BEGIN;

-- 第一次查询
SELECT * FROM employees WHERE salary > 5000; -- 返回3条记录

-- 事务B插入新员工并提交
INSERT INTO employees (name, salary) VALUES ('John', 6000);
COMMIT;

-- 事务A再次查询
SELECT * FROM employees WHERE salary > 5000; -- 仍返回3条（防止幻读？）
-- 但在MySQL中，可能会看到4条（幻读）
COMMIT;
```

**MySQL的特殊实现**：
- 使用MVCC + Next-Key Locking
- 部分防止幻读

### 4. **SERIALIZABLE（可串行化）**
最高级别隔离，完全隔离事务。

**特点**：
- 事务串行执行效果
- 防止所有并发问题
- 性能最低，一致性最强

```sql
-- 事务A
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
BEGIN;
SELECT SUM(balance) FROM accounts; -- 对表加共享锁

-- 事务B尝试插入
INSERT INTO accounts (id, balance) VALUES (100, 500);
-- 被阻塞，直到事务A提交

COMMIT A; -- 事务B才能继续
```

## 四、隔离级别的实现技术

### 1. **锁机制（Locking）**
传统实现方式，分为：
```sql
-- 共享锁（S锁）- 读锁
SELECT * FROM table LOCK IN SHARE MODE;

-- 排他锁（X锁）- 写锁  
SELECT * FROM table FOR UPDATE;

-- 意向锁（表级）
-- 记录锁、间隙锁、临键锁
```

### 2. **MVCC（多版本并发控制）**
现代数据库主流实现：
```sql
-- PostgreSQL示例：每行有隐藏的系统列
SELECT xmin, xmax, * FROM accounts WHERE id = 1;
-- xmin: 创建该行的事务ID
-- xmax: 删除/锁定该行的事务ID

-- 读操作：只能看到xmin已提交且xmax未提交或空的行
-- 写操作：创建新版本，旧版本保留
```

### 3. **快照隔离（Snapshot Isolation）**
```sql
-- SQL Server
SET TRANSACTION ISOLATION LEVEL SNAPSHOT;
BEGIN TRANSACTION;
-- 看到事务开始时的数据快照
-- 写操作时会检测写冲突
```

## 五、各数据库的隔离级别实现差异

| 数据库           | 默认级别        | 实现机制             | 特殊说明               |
| ---------------- | --------------- | -------------------- | ---------------------- |
| **MySQL InnoDB** | REPEATABLE READ | MVCC + Next-Key Lock | 可重复读下部分防止幻读 |
| **PostgreSQL**   | READ COMMITTED  | MVCC                 | 真正的快照隔离         |
| **Oracle**       | READ COMMITTED  | 多版本读一致性       | 串行化通过快照实现     |
| **SQL Server**   | READ COMMITTED  | 锁+行版本控制        | 默认启用行版本         |
| **SQLite**       | SERIALIZABLE    | 全局锁               | 写事务完全串行         |

## 六、隔离级别与并发问题关系

| 隔离级别 | 脏读   | 不可重复读 | 幻读   | 丢失更新 | 写偏斜 |
| -------- | ------ | ---------- | ------ | -------- | ------ |
| 读未提交 | ❌ 可能 | ❌ 可能     | ❌ 可能 | ❌ 可能   | ❌ 可能 |
| 读已提交 | ✅ 防止 | ❌ 可能     | ❌ 可能 | ❌ 可能   | ❌ 可能 |
| 可重复读 | ✅ 防止 | ✅ 防止     | ❌ 可能 | ❌ 可能   | ❌ 可能 |
| 串行化   | ✅ 防止 | ✅ 防止     | ✅ 防止 | ✅ 防止   | ✅ 防止 |

## 七、实际选择策略

### 场景1：OLTP在线交易系统
```sql
-- 推荐：READ COMMITTED
-- 原因：平衡性能与一致性
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;

BEGIN;
-- 处理订单、支付等
UPDATE inventory SET stock = stock - 1 WHERE product_id = 100;
INSERT INTO orders (...) VALUES (...);
COMMIT;
```

### 场景2：财务/银行系统  
```sql
-- 推荐：REPEATABLE READ 或 SERIALIZABLE
-- 原因：需要严格一致性
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

BEGIN;
-- 资金转账
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
-- 严格的串行执行，防止任何并发异常
COMMIT;
```

### 场景3：数据仓库/报表系统
```sql
-- 推荐：READ UNCOMMITTED（脏读）或快照
-- 原因：查询性能优先，容忍数据延迟
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

-- 大数据量统计查询
SELECT department, AVG(salary), COUNT(*)
FROM employees
GROUP BY department;
```

### 场景4：会话管理/用户状态
```sql
-- 推荐：使用乐观锁或应用层控制
-- 数据库级别设为READ COMMITTED
-- 应用层使用版本控制
UPDATE user_sessions 
SET last_activity = NOW(), version = version + 1
WHERE user_id = 123 AND version = @old_version;
```

## 八、性能影响分析

### 测试示例：不同隔离级别的性能对比
```sql
-- 创建测试表
CREATE TABLE perf_test (
    id INT PRIMARY KEY,
    value INT,
    INDEX idx_value (value)
);

-- 测试脚本：100个并发事务，每个事务：
-- READ UNCOMMITTED: ~50ms
-- READ COMMITTED:   ~80ms  
-- REPEATABLE READ:  ~120ms
-- SERIALIZABLE:     ~300ms
```

### 锁竞争程度：
```
锁竞争：串行化 > 可重复读 > 读已提交 > 读未提交
并发度：读未提交 > 读已提交 > 可重复读 > 串行化
```

## 九、最佳实践建议

### 1. **默认使用READ COMMITTED**
```sql
-- 在连接池或ORM中设置
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
-- 或
ALTER DATABASE mydb SET DEFAULT_TRANSACTION_ISOLATION TO 'READ COMMITTED';
```

### 2. **按需提升隔离级别**
```sql
-- 只在需要时使用更高级别
BEGIN;
SET LOCAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;
-- 执行敏感操作
COMMIT;
```

### 3. **监控隔离级别影响**
```sql
-- MySQL监控锁等待
SHOW ENGINE INNODB STATUS\G

-- PostgreSQL监控事务冲突
SELECT * FROM pg_stat_database WHERE datname = 'mydb';

-- 查看当前事务隔离级别
SELECT @@transaction_isolation;  -- MySQL
SHOW transaction_isolation;      -- PostgreSQL
```

### 4. **应用层配合策略**
```python
# Python示例：根据业务选择隔离级别
def transfer_funds(from_account, to_account, amount):
    # 财务转账使用更高级别
    with connection.transaction(isolation='SERIALIZABLE'):
        # 执行转账逻辑
        pass

def generate_report():
    # 报表查询使用更低级别  
    with connection.transaction(isolation='READ UNCOMMITTED'):
        # 执行统计查询
        pass
```

## 十、常见误区与陷阱

### 误区1：更高级别一定更好
```sql
-- 错误：所有事务都用串行化
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
-- 结果：系统并发性能极差，死锁频发

-- 正确：按需使用
-- 95%事务用READ COMMITTED
-- 5%敏感事务用更高级别
```

### 误区2：隔离级别解决所有并发问题
```sql
-- 即使SERIALIZABLE也不能解决所有业务逻辑问题
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
BEGIN;

-- 检查库存
SELECT stock FROM products WHERE id = 1; -- stock=1

-- 这里应用逻辑可能需要额外检查
-- 单纯依赖数据库隔离不够
UPDATE products SET stock = stock - 1 WHERE id = 1 AND stock > 0;

COMMIT;
```

### 误区3：所有数据库行为一致
```sql
-- MySQL可重复读 vs PostgreSQL可重复读
-- 同样的SQL可能产生不同结果
-- 需要了解具体数据库的实现细节
```

## 十一、现代发展趋势

### 1. **SSI（可串行化快照隔离）**
```sql
-- PostgreSQL 9.1+，真正的可串行化但性能更好
ALTER DATABASE mydb SET default_transaction_isolation = 'serializable';
-- 使用冲突检测而非完全锁
```

### 2. **分布式事务隔离**
```sql
-- 分布式数据库的特殊考虑
-- 全局事务ID、时钟同步、跨节点锁
-- Spanner的TrueTime，CockroachDB的HLC
```

### 3. **云原生数据库优化**
- 自动调整隔离级别
- 基于负载的动态切换
- 读写分离与一致性级别

## 总结

事务隔离是数据库并发控制的核心机制，需要在**数据一致性**和**系统性能**之间找到平衡点。正确的做法是：

1. **从READ COMMITTED开始**
2. **只在必要时提升级别**
3. **理解所用数据库的具体实现**
4. **配合应用层逻辑处理边界情况**
