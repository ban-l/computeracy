# 丢失更新问题

## 一、什么是丢失更新？

**丢失更新**是指两个或多个事务**同时读取同一数据**，然后分别基于读取的值进行修改，导致部分修改被覆盖的现象。

### 经典示例：银行转账余额更新
```sql
-- 初始余额：1000元
-- 事务A和事务B同时开始

-- 时间线：
1. 事务A读取余额：1000
2. 事务B读取余额：1000
3. 事务A计算：1000 - 200 = 800，更新余额为800
4. 事务B计算：1000 + 300 = 1300，更新余额为1300
5. 结果：最终余额为1300，事务A的-200更新丢失！
```

## 二、丢失更新的四种解决方案

### 方案1：使用**串行化隔离级别**（最简单但最重）

```sql
-- 设置事务为串行化隔离级别
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
BEGIN TRANSACTION;

SELECT balance FROM accounts WHERE id = 1; -- 读取
-- 计算...
UPDATE accounts SET balance = 新值 WHERE id = 1;

COMMIT;
```
**优点**：简单直接，数据库自动处理  
**缺点**：性能最差，并发度最低

### 方案2：使用**SELECT FOR UPDATE**（悲观锁）

```sql
BEGIN TRANSACTION;

-- 锁定要更新的行，阻止其他事务读取
SELECT balance FROM accounts WHERE id = 1 FOR UPDATE;

-- 此时其他事务的 SELECT FOR UPDATE 或 UPDATE 会被阻塞
-- 安全地进行计算和更新
UPDATE accounts SET balance = 新值 WHERE id = 1;

COMMIT;
```

**实现原理**：
- 对读取的行加**排他锁**
- 其他事务无法读取或修改这些行
- Oracle默认使用这种方式

**代码示例 - 库存扣减**：
```sql
-- 悲观锁方式解决库存超卖
BEGIN;
-- 1. 加锁查询
SELECT stock, version FROM products WHERE id = 1001 FOR UPDATE;

-- 2. 检查库存（假设stock=1）
IF stock >= 1 THEN
    -- 3. 更新库存
    UPDATE products SET stock = stock - 1 WHERE id = 1001;
    -- 记录订单...
END IF;

COMMIT;
```

### 方案3：使用**乐观锁**（通过版本号或时间戳）

```sql
-- 添加版本号字段
ALTER TABLE accounts ADD version INT DEFAULT 0;

-- 更新时检查版本号
BEGIN TRANSACTION;

-- 读取当前值和版本号
SELECT balance, version FROM accounts WHERE id = 1;

-- 在应用中计算新值，假设 version = 5

UPDATE accounts 
SET balance = 新值, version = version + 1 
WHERE id = 1 AND version = 5;

-- 检查是否更新成功
IF row_count() = 0 THEN
    -- 版本号不匹配，说明数据已被其他事务修改
    ROLLBACK;
    -- 重试或提示用户
ELSE
    COMMIT;
END IF;
```

**乐观锁变体 - 使用所有字段检查**：
```sql
UPDATE accounts
SET balance = 新值
WHERE id = 1 
  AND balance = 读取时的旧值
  -- 可以添加其他字段检查，如更新时间
  AND updated_at = 读取时的更新时间;
```

### 方案4：使用**原子操作**（最推荐）

直接使用SQL的原子操作，避免先读后写：

```sql
-- 直接原子更新，不需要先SELECT
UPDATE accounts 
SET balance = balance - 200  -- 或 balance + 300
WHERE id = 1;

-- 库存扣减的原子操作
UPDATE products 
SET stock = stock - 1 
WHERE id = 1001 AND stock > 0;
```

**复杂计算的原子操作示例**：
```sql
-- 基于条件更新
UPDATE orders 
SET status = 'SHIPPED',
    shipped_at = NOW(),
    shipper_id = 123
WHERE id = 456 
  AND status = 'PROCESSING';

-- 返回受影响的行数
SELECT ROW_COUNT(); -- 如果为0，说明状态已被改变
```

## 三、不同场景的解决方案选择

### 场景1：计数器/库存更新（最适用原子操作）
```sql
-- 正确做法
UPDATE product_inventory 
SET quantity = quantity - :purchase_qty,
    version = version + 1,
    updated_at = NOW()
WHERE product_id = :pid 
  AND quantity >= :purchase_qty;

-- 错误做法（有丢失更新风险）
BEGIN;
SELECT quantity FROM product_inventory WHERE product_id = :pid;
-- 应用中判断并计算新值
UPDATE product_inventory SET quantity = :new_qty WHERE product_id = :pid;
COMMIT;
```

### 场景2：复杂业务逻辑（适用乐观锁）
```sql
-- 银行转账复杂逻辑
BEGIN TRANSACTION;

-- 1. 读取带版本号
SELECT a.balance, a.version, b.balance, b.version
FROM accounts a, accounts b
WHERE a.id = :from_id AND b.id = :to_id;

-- 2. 应用中进行复杂验证和计算
-- 检查余额是否充足、是否超过单日限额等

-- 3. 乐观锁更新
UPDATE accounts 
SET balance = balance - :amount,
    version = version + 1,
    last_transaction = NOW()
WHERE id = :from_id 
  AND version = :old_version_from
  AND balance >= :amount;

UPDATE accounts 
SET balance = balance + :amount,
    version = version + 1
WHERE id = :to_id 
  AND version = :old_version_to;

-- 4. 检查两个更新是否都成功
IF (两个更新都影响1行) THEN
    COMMIT;
ELSE
    ROLLBACK;
    -- 重试逻辑
END IF;
```

### 场景3：文档/配置更新（适用悲观锁）
```sql
-- 用户配置合并更新
BEGIN TRANSACTION;

-- 锁定要更新的行
SELECT * FROM user_settings 
WHERE user_id = 123 
FOR UPDATE;

-- 读取当前配置
-- 合并新旧配置（在应用代码中）
-- 更新配置
UPDATE user_settings 
SET settings = :merged_settings,
    updated_at = NOW()
WHERE user_id = 123;

COMMIT;
```

## 四、框架和ORM中的解决方案

### JPA/Hibernate（使用@Version）
```java
@Entity
public class Account {
    @Id
    private Long id;
    private BigDecimal balance;
    
    @Version
    private Integer version;  // 乐观锁版本号
    
    // getters and setters
}

// 更新时自动处理乐观锁
public void transfer(Long fromId, Long toId, BigDecimal amount) {
    Account from = entityManager.find(Account.class, fromId);
    Account to = entityManager.find(Account.class, toId);
    
    from.setBalance(from.getBalance().subtract(amount));
    to.setBalance(to.getBalance().add(amount));
    
    // 提交时会自动检查version，如果变化则抛出OptimisticLockException
}
```

## 五、分布式系统下的丢失更新

在微服务/分布式系统中，问题更复杂：

### 分布式乐观锁模式
```sql
-- 使用全局版本号或时间戳
UPDATE distributed_table
SET data = :new_data,
    version = :new_version,
    updated_at = UTC_TIMESTAMP()
WHERE id = :id 
  AND version = :expected_version
  AND updated_at <= :expected_timestamp;
```

### 使用Redis分布式锁
```python
import redis
import time

def update_with_distributed_lock(resource_id, update_func):
    lock_key = f"lock:{resource_id}"
    
    # 尝试获取锁
    lock_acquired = redis_client.setnx(lock_key, "locked")
    if lock_acquired:
        redis_client.expire(lock_key, 10)  # 10秒超时
        
        try:
            # 执行更新
            update_func()
        finally:
            # 释放锁
            redis_client.delete(lock_key)
    else:
        # 锁获取失败，等待重试或返回错误
        raise ConcurrentUpdateError("资源被锁定")
```

## 六、最佳实践总结

1. **优先使用原子操作**：能用`UPDATE table SET field = field + 1`就不要先SELECT后UPDATE

2. **简单场景用悲观锁**：冲突频繁、数据竞争激烈的场景

3. **复杂业务用乐观锁**：冲突较少、需要重试逻辑的复杂业务

4. **设置合理超时和重试**：
```sql
-- 设置锁等待超时
SET innodb_lock_wait_timeout = 5;  -- MySQL
SET lock_timeout = '5s';           -- PostgreSQL
```

5. **监控和告警**：
```sql
-- 监控锁等待
SHOW ENGINE INNODB STATUS;  -- MySQL
SELECT * FROM pg_locks;     -- PostgreSQL
```

6. **应用层配合**：
   - 重试机制（指数退避）
   - 用户友好的错误提示
   - 操作日志记录

## 七、测试丢失更新

```sql
-- 测试脚本：模拟丢失更新
-- 会话1
BEGIN;
SELECT balance FROM accounts WHERE id = 1; -- 返回1000
-- 暂停，不提交

-- 会话2
BEGIN;
SELECT balance FROM accounts WHERE id = 1; -- 也返回1000
UPDATE accounts SET balance = 1300 WHERE id = 1;
COMMIT;  -- 余额变为1300

-- 会话1继续
UPDATE accounts SET balance = 800 WHERE id = 1; -- 基于1000计算
COMMIT;  -- 余额变为800，会话2的+300丢失！
```
