# 索引

在 MySQL 中（默认的 InnoDB 引擎），索引不仅仅是加速查询的工具，**它就是数据本身**。

## 一 B+ 树索引

### 1. 核心数据结构：B+ 树 (B+ Tree)

虽然 MySQL 支持哈希索引，但 InnoDB 的核心是 **B+ 树**。

为什么选择 B+ 树而不是二叉树或普通的 B 树？

1. **层高更低（减少磁盘 I/O）**：B+ 树一个节点（默认 16KB 页）可以存储成百上千个指针。这意味着即使是千万级的数据量，树的高度通常也只有 3 到 4 层。每一次查询只需要 3-4 次磁盘 I/O。
2. **便于范围查询**：B+ 树的所有叶子节点通过**双向链表**相连。执行 `WHERE id > 100` 时，找到 100 所在的叶子节点后，顺着链表往后取即可，无需像 B 树那样回溯遍历。
3. **数据都在叶子节点**：非叶子节点只存储索引（key），不存储实际行数据（value），这使得非叶子节点能容纳更多的索引项，进一步压低树高。

---

### 2. 物理存储分类：聚簇 vs 非聚簇

#### A. 聚簇索引 (Clustered Index)

* **定义**：索引结构的叶子节点**直接存储了完整的行数据**。
* **唯一性**：一张表只能有一个聚簇索引。
* **默认选择**：通常是**主键 (Primary Key)**。如果没有主键，InnoDB 会选择第一个非空的唯一索引；如果也没有，它会隐式生成一个 6 字节的 ROWID。
* **优势**：根据主键查询极其快，因为找到了索引就找到了数据。

#### B. 二级索引 (Secondary Index / Non-Clustered)

* **定义**：除了聚簇索引以外的所有索引（如普通索引、唯一索引、联合索引）。
* **结构**：叶子节点存储的是 **索引列的值 + 主键值**。
* **代价 - "回表" (Lookups)**：
  如果您执行 `SELECT * FROM users WHERE name = 'Alice'`（假设 name 有索引）：

1. 先在 `name` 的 B+ 树中找到 'Alice'，拿到对应的主键 ID。
2. **回表**：拿着主键 ID 去**聚簇索引**的 B+ 树中再次查找，才能获取整行数据。
   *这就是为什么不建议乱用 `SELECT *` 的核心原因之一。*

---

### 3. 核心法则：最左前缀原则 (Leftmost Prefix Rule)

这是**联合索引**（例如 `INDEX(a, b, c)`）生效的关键铁律。B+ 树是按照从左到右的顺序建立的。

假设有联合索引 `(a, b, c)`：

| SQL 查询条件            | 索引是否生效 | 原因                                                         |
| ----------------------- | ------------ | ------------------------------------------------------------ |
| `WHERE a = 1`           | ✅ 生效       | 命中了最左侧的 a                                             |
| `WHERE a = 1 AND b = 2` | ✅ 生效       | 连续命中 a, b                                                |
| `WHERE a = 1 AND c = 3` | ⚠️ 部分生效   | **索引截断**。a 生效，但 c 无法利用索引（中间跳过了 b）      |
| `WHERE b = 2 AND c = 3` | ❌ **失效**   | 没有从最左侧 a 开始                                          |
| `WHERE a > 1 AND b = 2` | ⚠️ 部分生效   | **范围查询阻断**。a 这种范围查询会生效，但后续的 b 无法再利用索引排序/查找。 |

## 二 哈希索引 (Hash Index)

这是最常见的一种替代方案，基于**哈希表**实现。

* **原理**：对索引列计算 Hash Code，直接定位到内存或磁盘的某个位置（Bucket）。
* **优势**：**极快**。时间复杂度为 O(1)，一次计算就能找到数据，比 B+ 树（O(logN)）更高效。
* **致命短板**：

1. **不支持范围查询**：`WHERE age > 18` 无法使用哈希索引，因为 Hash 值是没有顺序的。
2. **不支持排序**：`ORDER BY` 无效。
3. **不支持部分匹配**：无法像 B+ 树那样利用“最左前缀”，必须匹配完整的键。


* **应用场景**：
* **Redis**：Redis 的核心 KV 存储就是哈希索引。
* **MySQL Memory 引擎**：默认使用 Hash 索引。
* **InnoDB 的“自适应哈希索引”**：当 InnoDB 发现某些热点页被频繁访问时，会自动在内存中建立 Hash 索引来加速，这是数据库内部的自动优化。

## 三 倒排索引 (Inverted Index)

这是解决**文本搜索**问题的神器。

* **痛点**：在 MySQL 中用 `LIKE '%关键词%'` 会导致全表扫描，性能极差。
* **原理**：它不再记录“哪行数据包含什么字”，而是反过来记录**“这个字出现在哪些行里”**。
* 比如单词 "Java" -> 出现在文档 ID [1, 3, 9] 中。


* **应用场景**：
* **Elasticsearch (ES)** / Lucene：核心就是倒排索引。
* **MySQL 全文索引 (Full-Text)**：MySQL 5.6 之后 InnoDB 也开始支持，但功能不如 ES 强大。

## 四 LSM Tree (Log-Structured Merge Tree)

虽然它常被归类为存储引擎结构，但本质上它是一种**为“写”而生**的索引结构。

* **原理**：
* B+ 树为了维护有序性，写入时需要伴随大量的随机磁盘 I/O（页分裂、移动）。
* LSM Tree 将所有的**修改操作**看作追加日志（Append Only），先写内存（MemTable），满了就顺序刷入磁盘（SSTable）。这把随机写变成了**顺序写**。


* **优势**：**写入吞吐量极高**，远超 B+ 树。
* **短板**：**读性能略差**（可能需要去多个文件里查找），且存在“空间放大”和“写放大”问题（需要后台合并文件 Compaction）。
* **应用场景**：
* **NoSQL 数据库**：HBase, Cassandra, RocksDB。
* **NewSQL**：TiDB (底层 TiKV 使用 RocksDB)。
* 如果您的业务是“写多读少”的海量日志或监控系统，LSM Tree 是首选。

## 五 位图索引 (Bitmap Index)

这是数据仓库（OLAP）领域的利器。

* **原理**：用二进制位（0 和 1）来表示某个字段的值是否存在。
* 例如字段“性别”，只有男/女。
* 男：11010... （第 1、2、4 行是男）
* 女：00101... （第 3、5 行是女）


* **优势**：
* 空间极其紧凑。
* **位运算极快**：如果要查“男性 AND 已婚”，只需要对两个位图进行一次“按位与”操作，CPU 处理这种指令快得惊人。


* **短板**：**并发更新极其痛苦**。修改一个值需要锁住整个位图段，所以不适合高并发的事务型数据库（OLTP）。
* **应用场景**：Oracle, ClickHouse 等 OLAP 系统，用于处理枚举值很少的列（如状态、性别、标签）。

## 六 空间索引 (R-Tree)

用于处理地理位置数据（GIS）。

* **原理**：将二维平面的数据划分为多个矩形区域（MBR），通过树状结构快速判断坐标是否在某个区域内。
* **应用场景**：
* “查找我附近 5 公里的咖啡店”。
* MongoDB 的 `2dsphere`，PostgreSQL 的 `PostGIS`，以及 MySQL 的 `SPATIAL` 索引。

## 总结

| 索引类型     | 核心数据结构   | 杀手锏 (优势)           | 致命伤 (劣势)                  | 代表技术/场景        |
| ------------ | -------------- | ----------------------- | ------------------------------ | -------------------- |
| **B+ Tree**  | 平衡多路查找树 | 读写平衡，支持范围/排序 | 写入量极大时由于随机IO导致瓶颈 | MySQL, Oracle (默认) |
| **Hash**     | 哈希表         | **O(1) 极速查找**       | 不支持范围、排序               | Redis, Memory 引擎   |
| **LSM Tree** | 日志结构合并树 | **极致的写入性能**      | 读稍慢，需后台合并             | HBase, RocksDB, TiDB |
| **倒排索引** | 词项-文档映射  | **全文搜索**            | 更新成本高                     | Elasticsearch        |
| **Bitmap**   | 位数组         | **多条件组合过滤极快**  | 锁粒度大，不适合高频更新       | ClickHouse, OLAP     |

作为开发工程师，在设计数据库时，注意：

1. **区分度高**的列才建索引（如性别就不适合，只有男女，区分度太低）。
2. **主键尽可能短**（因为所有二级索引都包含主键，主键太长会导致索引膨胀）。
3. 利用**覆盖索引**减少 I/O。
4. 时刻谨记**最左前缀**。
