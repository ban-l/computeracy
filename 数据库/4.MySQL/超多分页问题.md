# 超多分页问题

在MySQL中，当处理**超大数据集的分页**时，传统 `LIMIT offset, size` 的性能会急剧下降（因为需要扫描 `offset + size` 行数据）。

## 一、缓存

可预测性的提前查到内容，缓存至redis等k-V数据库中，直接返回即可。

## 二、利用**延迟关联**或者**子查询**

1. MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下：
   1. 要么控制返回的总页数。
   2. 要么对超过特定阈值的页数进行 SQL 改写。
2. 正例：先快速定位需要获取的 **id** 段，然后**再关联**

```mysql
SELECT t1.* FROM 表 1 as t1 , 
(select id from 表 1 where 条件 LIMIT 100000 , 20) as t2
where t1.id = t2.id
```

## 三、基于游标的分页方式

- 使用上一页最后一条记录的排序字段（如时间戳、ID 等）作为“游标”，来实现高效分页。
- 下一页查询时从该游标之后的数据开始取，避免跳过大量数据。

------

### 1. 传统分页的问题

```sql
-- 当 offset 很大时性能极差（需扫描前 1,000,000 行）
SELECT * FROM large_table ORDER BY id LIMIT 1000000, 10;
```

------

### 2. 基于游标的分页实现原理

1. **核心思想**： 用上一页最后一条记录的**有序唯一值（如主键、时间戳等）** 作为起点，直接“锚定”位置。
2. **优势**：
   - 跳过 `offset` 扫描，查询时间恒定
   - 适合无限滚动场景
   - 不受新增/删除数据影响（游标稳定）

------

### 3. 优化步骤与示例

### 场景：按主键 `id` 分页（单字段游标）

```sql
-- 第一页（取 10 条）
SELECT * FROM large_table ORDER BY id ASC LIMIT 10;

-- 下一页：用上一页最后一条的 id 作为游标
SELECT * FROM large_table
WHERE id > 上一页最后一条的id  -- 关键锚点
ORDER BY id ASC
LIMIT 10;
```

### 场景：按非唯一字段分页（多字段游标）

```sql
-- 按 created_at 分页（可能存在重复值），增加 id 保序
SELECT * FROM large_table
ORDER BY created_at ASC, id ASC  -- 确保顺序唯一性
LIMIT 10;

-- 下一页（假设上一页最后一条：created_at='2023-01-01', id=100）
SELECT * FROM large_table
WHERE (created_at > '2023-01-01')
   OR (created_at = '2023-01-01' AND id > 100)  -- 处理相同 created_at
ORDER BY created_at ASC, id ASC
LIMIT 10;
```

------

### 4. 关键优化点

1. **必须使用有序且唯一的字段组合**

   - 单字段：主键 `id`、时间戳 `timestamp`（确保无重复）
   - 多字段：`(created_at, id)` 组合（常见方案）

2. **索引优化**

   ```sql
   -- 为排序字段创建联合索引
   ALTER TABLE large_table ADD INDEX idx_cursor_key (created_at, id);
   ```

3. **客户端配合**

   - 前端传递 `last_cursor` 值（如 `last_created_at&last_id`）
   - 后端解析后拼接到 SQL 的 `WHERE` 条件

------

### 5. 对比传统分页性能

| 方案             | 10万行数据耗时 | 1000万行数据耗时 | 特点                     |
| ---------------- | -------------- | ---------------- | ------------------------ |
| `LIMIT 90000,10` | ~300 ms        | ~5 秒            | 随 offset 线性增长       |
| **游标分页**     | **~1 ms**      | **~1 ms**        | 恒定时间，不受数据量影响 |

------

### 6. 适用场景与限制

- **适用**：无限滚动、实时流数据、APP 分页加载
- **不适用**：需要跳转到任意页面的场景（如第 100 页）
- **注意**：排序字段必须稳定（若数据频繁更新需结合业务逻辑处理）

通过游标分页，MySQL 处理千万级数据分页时仍能保持毫秒级响应，是解决深度分页问题的标准方案。
