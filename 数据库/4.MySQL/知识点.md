# 知识点

## 1.大表数据优化

当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：

1. 限定数据的范围；
2. sql语句+索引；
3. 加缓存；
4. 主从复制，读写分离；
5. 垂直拆分，根据模块的耦合度，将一个大系统分为多个小系统，即分布式系统；
6. 水平切分，针对数据量大的表：
   - 选择一个合理的sharding key；
   - 表结构也要改动，做一定的冗余；
   - 应用也要改动，sql中尽量带sharding key，将数据定位到限定表，而不是扫描全部的表。

## 2.数据库结构优化

一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。

需要考虑**数据冗余、查询和更新的速度、字段的数据类型**是否合理等多方面的内容。

1. 将字段很多的表分解成多个表：
   1. 对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表；
   2. 因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。
2. 增加中间表：
   1. 对于需要经常联合查询的表，可以建立中间表以提高查询效率。
   2. 通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。
3. 增加冗余字段
   1. 设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。
   2. 但是，合理的加入冗余字段可以提高查询速度。
   3. 注意，冗余字段的值在一个表中修改了，就要在其它表中更新，否则导致数据不一致。
4. 表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。

## 3.SQL 约束

1. NOT NULL：约束字段的内容一定不能为空。
2. UNIQUE：约束字段内容不能重复，一个表允许有多个 Unique 约束。
3. PRIMARY KEY：约束字段内容不能重复，但它在一个表只允许出现一个。
4. FOREIGN KEY：预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。
5. CHECK：约束字段的值范围。
6. 默认

## 4.IN 与 EXISTS

| 关键字     | 运作机制                                                     | 最佳场景                                                 |
| ---------- | ------------------------------------------------------------ | -------------------------------------------------------- |
| **IN**     | 先把子查询全部执行完，把结果集缓存，再过滤外部表。           | **子查询结果集很小**，外部表很大时。                     |
| **EXISTS** | 外部表走一行，就去子查询里看一眼“有没有”。一旦找到匹配就停止（不再扫描剩余数据）。循环。 | **子查询表很大**，但外部表较小时（或者两者都有索引时）。 |

假设子查询结果集为B，共有m条记录，然后将结果集B分解成m个，再进行m次查询（外表）。

假设A表（外表）有n条记录，exists就是将n条记录逐条取出，然后判断n遍exists条件。

in  当于多个or条件的叠加，下面两条语句等价：

```sql
select * from user where user_id in (1, 2, 3);
select * from user where  user_id = 1 or user_id = 2 or user_id = 3;
```

**示例 (查询下过订单的用户)**：
如果 `orders` 表有几千万条数据，而 `users` 表很小：

```sql
-- 推荐使用 EXISTS
SELECT * FROM users u
WHERE EXISTS (
    SELECT 1 FROM orders o WHERE o.user_id = u.id
);
```

### exists 和 in 比较

- 如果查询的两个表大小相当（外表和子查询结果集），in和exists差别不大；
- 若子查询结果集大的用 exists；
- 若子查询结果集小的用 in；
- In查询在内部表和外部表上都可以使用到索引；
- Exists查询仅在内部表上可以使用到索引。

### not in 和 not exists 比较

如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；

not extsts的子查询依然能用到索引；

所以无论那个表大，not exists都比not in要快。

## 5.drop、delete与truncate

| 维度\操作 | Delete                            | Truncate                 | Drop         |
| --------- | --------------------------------- | ------------------------ | ------------ |
| 类型      | DML                               | DDL                      | DDL          |
| 回滚      | 可回滚                            | 不可回滚                 | 不可回滚     |
| 删除内容  | 表结构还在，删除全部数据/部分数据 | 表结构还在，删除全部数据 | 删除所有     |
| 删除速度  | 删除速度慢，逐行删除              | 删除速度快               | 删除速度最快 |

## 5.存储过程

存储过程是一系列预编译的 SQL 语句，执行效率比较高，一个存储过程替代大量 SQL 语句，可以降低网络通信量，提高通信速率，可以一定程度上确保数据安全。

好处：

- 代码封装，保证了一定的安全性；
- 代码复用；
- 由于是预先编译，具有很高性能。