# 存储引擎

MySQL 就像汽车的底盘和外壳（负责连接、SQL解析、优化），而存储引擎则是发动机（负责数据的真正存储和提取）。

你可以在同一辆车（同一个数据库）里，给不同的轮子（不同的表）装上不同的发动机。

目前主流的存储引擎主要就是这两个：**InnoDB** 和 **MyISAM**。

---

## 1. InnoDB：现代数据库的中流砥柱

从 MySQL 5.5 版本开始，InnoDB 成为了**默认**的存储引擎。如果你没有特殊理由，**99% 的场景都应该闭眼选 InnoDB**。

#### 核心特性

* **支持事务 (ACID)**：这是它与 MyISAM 最大的区别。它支持 commit、rollback 和 crash recovery（崩溃恢复）。对于支付、订单等对数据一致性要求极高的系统，InnoDB 是唯一选择。
* **行级锁 (Row-Level Locking)**：它是为了高并发而生的。只要查询条件命中了索引，InnoDB 就可以只锁住那一行数据，而不是锁住整张表。这让多个用户同时操作一张表成为可能。
* **外键约束 (Foreign Keys)**：保证数据的完整性。
* **MVCC (多版本并发控制)**：支持高并发读写不冲突（你之前调研过的 MVCC 就是在 InnoDB 这一层实现的）。

### 物理存储结构 (聚簇索引)

这是 InnoDB 性能的关键。

* **数据即索引**：在 InnoDB 中，表数据文件本身就是按 B+ 树组织的一个索引结构。主键索引的叶子节点中，直接存储了**完整的行数据**。
* **文件格式**：通常是 `.ibd` 文件（表空间文件）。

> **提示**：在 InnoDB 表中**必须建议定义主键**，且最好是**自增整数**。如果主键是随机 UUID，插入时会导致 B+ 树频繁分裂和页面移动，性能大幅下降。

---

## 2. MyISAM：时代的眼泪（但在特定领域依然有用）

在 MySQL 5.5 之前，它是默认引擎。它设计简单，侧重于读取性能，但牺牲了事务和写入并发能力。

### 核心特性

* **不支持事务**：没有 Undo Log 和 Redo Log，一旦数据库崩了，数据恢复比较麻烦，且不保证原子性。
* **表级锁 (Table-Level Locking)**：这是它最大的短板。无论你读还是写，它都会锁住**整张表**。适合“读多写极少”的场景。
* **全文索引 (Full-Text Search)**：早期是 MyISAM 的独门绝技，但 InnoDB 从 5.6 版本开始也支持了，所以这个优势已经不复存在。

### 物理存储结构 (非聚簇索引)

* **索引与数据分离**：MyISAM 的索引文件和数据文件是分开的。索引（B+树）的叶子节点存储的是**数据记录的物理地址**（指针），拿到地址后，还需要去数据文件中再捞一次。
* **文件格式**：
* `.MYD` (MYData) - 存数据
* `.MYI` (MYIndex) - 存索引
* `.sdi` (早版本是 .frm) - 存表结构

---

## 3. InnoDB vs MyISAM

| 特性 | InnoDB (建议默认) | MyISAM (谨慎使用) |
| --- | --- | --- |
| **事务支持** | **支持** (ACID) | 不支持 |
| **锁机制** | **行锁** (适合高并发) | 表锁 (并发写性能差) |
| **外键** | 支持 | 不支持 |
| **数据恢复** | 强 (Redo Log 崩溃自动恢复) | 弱 (可能丢数据) |
| **COUNT(*)** | 慢 (需要全表/全索引扫描) | **快** (内部维护了一个计数器，直接读) |
| **索引结构** | **聚簇索引** (主键即数据) | 非聚簇索引 (索引指向地址) |
| **适用场景** | 99% 的业务系统 (电商、金融、OA) | 极端的读多写少、纯日志归档 |

> **Count(*) 陷阱**：
> 很多老教材会说 `SELECT COUNT(*) FROM table` 很快。**这只对 MyISAM 有效**。
> 对于 InnoDB，因为有 MVCC（不同事务看到的数据行数可能不同），数据库必须一行行去数，所以随着数据量增加，InnoDB 的 `COUNT(*)` 会变慢。

---

## 4. 其他小众引擎（了解即可）

* **Memory (Heap)**：数据全部在内存中，速度极快，但重启服务数据就丢了。常用于临时表。
* **Archive**：仅仅支持插入和查询，不支持修改和删除。存储时会高压缩。适合存海量的历史日志。

---

## 5. 选择指南

作为 Java 工程师，在 Spring Boot + MyBatis/JPA 的架构下：

1. **建表时**：除非你有极其特殊的理由（比如只读的历史报表库），否则永远显式指定 `ENGINE=InnoDB`。
2. **遇到性能问题时**：不要试图通过切回 MyISAM 来优化读取速度。现在的 InnoDB 经过缓冲池（Buffer Pool）优化，读取性能已经非常强悍。
3. **关于 Count(*)**：如果你的业务需要频繁显示“总行数”（比如分页），且数据量在千万级，不要直接依赖 InnoDB 的 `COUNT(*)`，建议引入 Redis 缓存计数或者看大致估算值（`SHOW TABLE STATUS`）。
