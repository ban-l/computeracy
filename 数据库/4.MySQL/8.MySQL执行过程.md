# MySQL执行过程

如果把 MySQL 看作一家**“高档餐厅”**，那么一条 SQL 查询的执行过程，就是从“客人点菜”到“后厨出餐”的全过程。

我们可以将 MySQL 的架构分为两层：

1. **Server 层（大堂经理、服务员）**：负责连接、分析、优化、执行。所有的跨引擎功能（如存储过程、触发器、视图）都在这一层。
2. **存储引擎层（后厨、厨师）**：负责数据的存储和提取（InnoDB, MyISAM 等）。

下面我将以一条简单的查询语句为例，拆解它的**七步奇幻漂流**：

```
SELECT name FROM users WHERE id = 1;
```

------

## 第一步：连接器 (The Connector) —— 接待客人

首先，你的 Java 应用（通过 JDBC 或 MyBatis）需要和 MySQL 建立连接。

- **动作**：TCP 握手，验证用户名密码。
- **权限校验**：一旦连接建立，你拥有的权限（读、写、删）就已经确定了。即使管理员中途给你加了权限，在这个旧连接中断前也不会生效。
- **专家提示**：Java 里的 `Druid` 或 `HikariCP` 连接池就是维护这一层的，避免频繁建立 TCP 连接带来的开销。

## 第二步：查询缓存 (Query Cache) —— 查旧菜单（已废弃）

- **逻辑**：MySQL 拿到 SQL 后，先看缓存里有没有完全一样的 SQL。如果有，直接返回结果。
- **现状**：**MySQL 8.0 已经彻底删除了这个功能**。
- **原因**：弊大于利。缓存失效非常频繁（只要表有一点更新，该表所有缓存全清空），对于更新频繁的系统，这简直是灾难。

## 第三步：分析器 (Parser) —— 也就是“点菜员”

如果你没命中缓存，就进入真正的执行阶段。

1. **词法分析**：把字符串拆成标记（Token）。识别出 `SELECT` 是关键字，`users` 是表名，`id` 是列名。
2. **语法分析**：判断你的 SQL 是否符合语法规则。
   - *错误示例*：如果你写了 `SELETC ...`，会在这里报错：`You have an error in your SQL syntax`。

## 第四步：预处理器 (Preprocessor) —— 语义检查

语法没问题，不代表 SQL 能跑。

- **动作**：检查表 `users` 是否真的存在？列 `name` 是否真的存在？
- **错误示例**：`Unknown column 'xyz' in 'field list'` 就是在这里报出来的。

## 第五步：优化器 (Optimizer) —— **核心大脑（大堂经理）**

这是 Server 层最关键的一步。

即便你的 SQL 很简单，MySQL 也要决定“怎么查最快”。

- **决策内容**：
  - 表里有多个索引（如 `id` 主键索引，`name` 普通索引），用哪一个？
  - 如果是多表 Join，先查哪张表，后查哪张表？（MySQL 可能会改变你写的 JOIN 顺序以获得更优路径）。
- **结果**：生成**执行计划 (Execution Plan)**。
- **关联工具**：我们在性能优化部分提到的 `EXPLAIN`，看到的就是这一步的产出。

## 第六步：执行器 (Executor) —— 传菜员

优化器定好了方案，执行器开始干活。

1. **权限复查**：再次确认你是否有查 `users` 表的权限。
2. **调用引擎接口**：执行器本身不存数据，它通过调用**存储引擎的 API** 来获取数据。
   - *如果是全表扫描*：执行器会循环调用引擎接口：“给我下一行”，直到读完。
   - *如果是索引扫描*：调用接口：“给我满足 id=1 的这一行”。

## 第七步：存储引擎 (Storage Engine) —— 后厨厨师 (InnoDB)

这是数据真正存放的地方。

1. **查缓冲池 (Buffer Pool)**：InnoDB 非常聪明，它不会直接去磁盘找。它先看内存里的 Buffer Pool 有没有这就数据页。如果有（内存命中），直接返回，速度极快。
2. **查磁盘**：如果内存没有，它会将磁盘上的数据页加载到内存中，再返回给执行器。

------

## 总结

整个流程可以浓缩为：

**连接 -> (缓存) -> 分析 -> 优化 -> 执行 -> 引擎 -> 磁盘/内存**

**“更新语句” (UPDATE)** 的特殊步骤。

如果执行的是 `UPDATE users SET name = 'Bob' WHERE id = 1;`，流程基本一样，但在**第七步**，InnoDB 会引入两个关键日志来保证数据安全（这也是面试高频考点）：

1. **Redo Log (重做日志)**：InnoDB 特有。记录“在某个数据页上做了什么修改”。它保证了即使数据库宕机，重启后数据也能恢复（**Crash Safe**）。
2. **Binlog (归档日志)**：Server 层共有。记录了完整的逻辑操作。用于主从复制和数据备份。
3. **两阶段提交 (Two-Phase Commit)**：为了让这两个日志逻辑一致，MySQL 内部使用两阶段提交（Prepare -> Write Binlog -> Commit）来执行。

------

这个流程解释了为什么优化 SQL 时：

- **建好索引很重要**：为了帮“优化器”选出最好的路。
- **内存很重要**：为了让“存储引擎”尽量在 Buffer Pool 里就找到数据，别去碰慢吞吞的磁盘。