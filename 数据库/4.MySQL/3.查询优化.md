# 查询优化

这是数据库领域价值最高的话题。写出能跑的 SQL 容易，写出**高性能**的 SQL 则是资深工程师的核心竞争力。

优化查询性能通常遵循一个“漏斗模型”：

1. **先看执行计划**
2. **再调优索引**
3. **最后改写 SQL 逻辑**

---

## 第一步：诊断——学会看 `EXPLAIN`

在动手修改 SQL 之前，必须先“体检”。几乎所有关系型数据库（MySQL, PostgreSQL, Oracle）都提供 `EXPLAIN` 命令。

你需要重点关注 `EXPLAIN` 结果中的以下三列（以 MySQL 为例）：

1. **`type` (访问类型)**：这是性能的晴雨表。
* **优**：`const` (主键/唯一索引查找), `ref` (非唯一索引查找), `range` (索引范围查找)。
* **差**：`index` (全索引扫描), `ALL` (全表扫描 - **这是由于缺少索引导致的性能杀手**)。


2. **`key` (实际使用的索引)**：数据库最终决定用了哪个索引。如果是 `NULL`，说明没走索引。
3. **`rows` (扫描行数)**：数据库估计要扫描多少行才能找到结果。这个数字越小越好。

---

## 第二步：核心——索引优化的黄金法则

索引是提升查询速度最直接的手段，但索引不是越多越好，关键在于**怎么用**。

### 1. 最左前缀原则 (The Leftmost Prefix Rule)

这是联合索引（Composite Index）中最容易被忽略的规则。
假设你建立了一个联合索引 `idx_user (name, age, city)`，它相当于创建了三个索引：`(name)`, `(name, age)`, `(name, age, city)`。

* **有效查询**：
* `WHERE name = 'Alice'` (命中)
* `WHERE name = 'Alice' AND age = 25` (命中)


* **失效查询 (索引断层)**：
* `WHERE age = 25` (跳过了头部的 name，**完全失效**)
* `WHERE city = 'Beijing'` (跳过了头部，**完全失效**)
* `WHERE name = 'Alice' AND city = 'Beijing'` (name 走索引，但中间断了 age，city 字段只能在结果中过滤，索引利用不完全)。

### 2. 覆盖索引 (Covering Index)

这是也是一个非常高阶的优化技巧。
如果你的 SQL 语句中 `SELECT` 的字段，**刚好**都在联合索引的 Key 里，数据库就不需要回表（Back to Table）去查原始数据行。

* **场景**：索引是 `(name, age)`
* **慢**：`SELECT * FROM users WHERE name = 'Alice';` (需要回表查其他字段)
* **快**：`SELECT name, age FROM users WHERE name = 'Alice';` (直接从索引树上拿数据，速度极快)

---

## 第三步：实战——SQL 语句避坑指南

很多性能问题是由“坏的编码习惯”引起的。以下是 5 个最常见的“反模式”及其修正方案：

### 1. 避免在索引列上做运算

**错误**：

```sql
-- 这种写法会导致索引失效，因为数据库必须算出每一行的结果才能对比
SELECT * FROM orders WHERE YEAR(create_time) = 2023;
```

**正确**：

```sql
-- 把计算转移到等号右边，保持左边列的纯净
SELECT * FROM orders WHERE create_time BETWEEN '2023-01-01' AND '2023-12-31';
```

### 2. 隐式类型转换 (Implicit Conversion)

这通常发生在 Java 和 数据库类型不匹配时。

* **场景**：数据库字段 `phone` 是 `VARCHAR` 类型。
* **错误**：`SELECT * FROM users WHERE phone = 13800000000;` (传入了数字)
* 数据库为了比较，会把每一行的 `phone` 转成数字，导致全表扫描。


* **正确**：`SELECT * FROM users WHERE phone = '13800000000';` (传入字符串)

### 3. 慎用 SELECT *

* **I/O 浪费**：取出了很多不需要的字段，增加了网络传输和内存开销。
* **扼杀覆盖索引**：`SELECT *` 几乎必然导致回表操作，无法利用覆盖索引的优势。

### 4. `OR` 条件的陷阱

在某些旧版本的数据库引擎中，`WHERE id = 1 OR id = 2` 可能会导致索引失效。

**优化建议**：尽量使用 `UNION ALL` 代替 `OR`，或者使用 `IN` (但在列表很大时 `IN` 也会慢)。

### 5. 深分页问题 (Deep Paging)

当业务翻页到很后面时，性能会急剧下降。

* **场景**：`LIMIT 1000000, 10`
* 数据库需要读取 1,000,010 行数据，抛弃前 100万行，只留最后 10 行。


* **优化**：
* **标签法（游标）**：记录上一页最后一条数据的 ID。
* `SELECT * FROM users WHERE id > 1000000 LIMIT 10;` (直接利用主键跳转，效率提升巨大)。

---

## 总结

1. **先看 EXPLAIN**，确定瓶颈是全表扫描还是索引效率低。
2. **检查最左前缀**，确保 `WHERE` 条件用上了联合索引。
3. **改写 SQL**，移除列运算，解决隐式转换，优化分页。
