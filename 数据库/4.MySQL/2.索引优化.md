# 索引优化

## 1. 高级优化技巧：覆盖索引 (Covering Index)

这是解决“回表”性能问题的终极手段。

**概念**：如果一个索引包含（覆盖）了查询语句中需要的所有字段，就不需要再回表查询。

* **场景**：
  有一个索引 `idx_key(name, age)`。
* **查询 A (回表)**：

```sql
SELECT * FROM users WHERE name = 'Alice';
-- 需要回表去拿 email, address 等其他字段。

```


* **查询 B (覆盖 - 极快)**：

```sql
SELECT name, age, id FROM users WHERE name = 'Alice';
-- 需要的字段（name, age）都在索引树上，id 也在（二级索引存主键），直接返回，无需回表。

```


**优化建议**：对于高频查询，尽量设计联合索引来覆盖所需字段。

---

## 2. 索引失效的常见场景

即使建了索引，写得烂的 SQL 也会导致索引失效（全表扫描）：

1. **函数运算**：`WHERE YEAR(create_time) = 2024`（应对字段进行计算）。
2. **隐式类型转换**：`WHERE phone_varchar = 123456`（字符串没加单引号，转数字导致全表扫描）。
3. **模糊查询左通配**：`WHERE name LIKE '%James'`（B+ 树是从左往右排的，左边都不确定，无法查）。
4. **`OR` 条件**：如果 `OR` 两边的字段不全都有索引，引擎往往会放弃索引选择全表扫描。

## 3. 独立列

进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。

## 4. 多列索引

使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引，性能更好。

## 5. 索引列顺序

选择性最强的索引列放在前面，选择性越高，每个记录的区分度越高，查询效率也越高。

索引选择性指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。

## 6. 前缀索引

对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。前缀长度的选取需要根据索引选择性来确定。

## 7. 索引的优点

1. 大大减少了服务器需要扫描的数据行数。
2. 帮助服务器避免进行排序和分组，以及避免创建临时表。
   1. B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。
   2. 临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表。
3. 将随机  I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻数据都存储在一起）。

## 8. 索引的使用条件

1. 非常小的表（不用索引）：大部分情况下简单的全表扫描比建立索引更高效（不用索引）。
2. 中到大型的表（用索引）：索引就非常有效。
3. 但是对于特大型的表，建立和维护索引的代价将会随之增长，可以使用分区技术。