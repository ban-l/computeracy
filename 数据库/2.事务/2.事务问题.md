# 事务问题

## 一、并发事务问题（ACID中的"I"问题）

### **1. 脏读（Dirty Read）**
**问题**：读取到其他事务**未提交**的数据。
```sql
-- 事务A（更新但未提交）
BEGIN;
UPDATE users SET balance = balance - 100 WHERE id = 1;
-- balance从1000变为900，但未提交

-- 事务B（脏读发生）
-- 隔离级别为READ UNCOMMITTED时：
SELECT balance FROM users WHERE id = 1; -- 读到900

-- 事务A回滚
ROLLBACK; -- balance恢复为1000
-- 事务B读到的900是"脏数据"，实际从未存在过
```

**影响**：
- 基于不存在的数据做出错误决策
- 财务系统会显示错误的余额

### **2. 不可重复读（Non-repeatable Read）**
**问题**：同一事务内，多次读取同一数据得到**不同结果**。
```sql
-- 事务A
BEGIN;
SELECT balance FROM accounts WHERE id = 1; -- 第一次：1000

-- 事务B更新并提交
UPDATE accounts SET balance = 900 WHERE id = 1;
COMMIT;

-- 事务A再次读取
SELECT balance FROM accounts WHERE id = 1; -- 第二次：900
-- 两次读取结果不一致！
COMMIT;
```

**影响**：
- 统计计算不准确
- 需要数据一致性的业务逻辑出错

### **3. 幻读（Phantom Read）**
**问题**：同一事务内，多次**范围查询**返回不同的**行集合**。
```sql
-- 事务A
BEGIN;
SELECT * FROM orders WHERE status = 'PENDING'; -- 返回5条记录

-- 事务B插入新订单并提交
INSERT INTO orders (status) VALUES ('PENDING');
COMMIT;

-- 事务A再次查询
SELECT * FROM orders WHERE status = 'PENDING'; -- 返回6条记录
-- 出现了"幻影行"！
COMMIT;
```

**与不可重复读的区别**：
- 不可重复读：同一条记录的**值**变化
- 幻读：**行数**变化（新增或删除）

### **4. 丢失更新（Lost Update）**
**问题**：两个事务同时读取并更新同一数据，一个更新被覆盖。
```sql
-- 初始值：库存 stock = 10
-- 事务A：销售5件
BEGIN;
SELECT stock FROM products WHERE id = 1; -- 读到10
UPDATE products SET stock = 10 - 5 WHERE id = 1; -- 设为5

-- 事务B：补货8件（同时发生）
BEGIN;
SELECT stock FROM products WHERE id = 1; -- 也读到10
UPDATE products SET stock = 10 + 8 WHERE id = 1; -- 设为18

COMMIT A; COMMIT B;
-- 最终stock = 18，事务A的更新丢失！
```

### **5. 写偏斜（Write Skew）**
**问题**：两个事务基于**不同但相关**的数据做出决策，导致整体不一致。
```sql
-- 医生值班系统：至少需要一名医生值班
-- 当前值班医生：Alice, Bob

-- 事务A（Alice请假）
BEGIN;
SELECT COUNT(*) FROM doctors WHERE on_call = true; -- 返回2
-- 判断：有2人值班，Alice可以请假
UPDATE doctors SET on_call = false WHERE name = 'Alice';

-- 事务B（Bob同时请假）
BEGIN;
SELECT COUNT(*) FROM doctors WHERE on_call = true; -- 也返回2
-- 判断：有2人值班，Bob可以请假
UPDATE doctors SET on_call = false WHERE name = 'Bob';

COMMIT A; COMMIT B;
-- 结果：无人值班！违反业务规则
```

### **6. 读偏斜（Read Skew）**
**问题**：读取到**逻辑上不一致**的多个相关数据。
```sql
-- 银行账户：检查账户A+B的总余额
-- 初始：A=500, B=500，总额=1000

-- 事务A（转账）
BEGIN;
UPDATE accounts SET balance = balance - 200 WHERE id = 'A'; -- A=300
UPDATE accounts SET balance = balance + 200 WHERE id = 'B'; -- B=700

-- 事务B（在转账中间查询）
BEGIN;
SELECT balance FROM accounts WHERE id = 'A'; -- 读到300（已更新）
-- 此时事务A还在执行...
SELECT balance FROM accounts WHERE id = 'B'; -- 读到500（未更新）
-- 合计=800，但实际应该是1000！
COMMIT A; COMMIT B;
```

## 二、锁相关的问题

### **1. 死锁（Deadlock）**
**问题**：两个或多个事务互相等待对方释放锁。
```sql
-- 事务A
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1; -- 锁住id=1
-- 等待锁住id=2...

-- 事务B（同时）
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 2; -- 锁住id=2
-- 等待锁住id=1...

-- 结果：互相等待，死锁发生！
```

**数据库处理**：
- 检测到死锁，选择牺牲者回滚
- MySQL：`ERROR 1213 (40001): Deadlock found`

### **2. 锁等待超时（Lock Timeout）**
**问题**：事务等待锁的时间超过阈值。
```sql
-- 事务A持有锁时间过长
BEGIN;
SELECT * FROM large_table FOR UPDATE;
-- 执行复杂操作，长时间不提交...

-- 事务B尝试获取锁
BEGIN;
SELECT * FROM large_table FOR UPDATE NOWAIT;
-- 立即返回：ORA-00054: resource busy and acquire with NOWAIT specified
-- 或等待超时后失败
```

### **3. 锁升级（Lock Escalation）**
**问题**：数据库为节省资源，将多个行锁升级为表锁。
```sql
-- 事务A更新大量行
BEGIN;
UPDATE orders SET status = 'SHIPPED' WHERE customer_id = 123;
-- 更新1000行，可能产生1000个行锁

-- 数据库可能自动升级为表锁
-- 此时事务B无法查询任何订单
SELECT COUNT(*) FROM orders; -- 被阻塞
```

## 三、系统故障问题

### **1. 事务中断**
**问题**：事务执行过程中系统崩溃。
```sql
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
-- 系统在此处崩溃！
-- 重启后：部分更新？全部更新？全部回滚？
```

**解决方案**：WAL（Write-Ahead Logging）保证原子性。

### **2. 长时间运行事务**
**问题**：事务运行时间过长。
```sql
BEGIN;
-- 处理百万行数据
UPDATE huge_table SET status = 'processed' WHERE condition;
-- 运行了2小时...
COMMIT;
```

**影响**：
- 锁持有时间过长
- 阻塞其他事务
- 回滚段/undo日志膨胀

### **3. 大事务问题**
**问题**：单事务修改数据量过大。
```sql
BEGIN;
-- 删除大量数据
DELETE FROM log_table WHERE created_at < '2023-01-01';
-- 影响1000万行
COMMIT;
```

**风险**：
- 耗尽undo空间
- 主从复制延迟
- 锁表时间过长

## 四、隔离级别与问题对应表

| 问题       | 读未提交 | 读已提交 | 可重复读 | 串行化 |
| ---------- | -------- | -------- | -------- | ------ |
| 脏读       | ✅ 发生   | ❌ 防止   | ❌ 防止   | ❌ 防止 |
| 不可重复读 | ✅ 发生   | ✅ 发生   | ❌ 防止   | ❌ 防止 |
| 幻读       | ✅ 发生   | ✅ 发生   | ⚠️ 可能   | ❌ 防止 |
| 丢失更新   | ✅ 发生   | ✅ 发生   | ✅ 发生   | ❌ 防止 |
| 写偏斜     | ✅ 发生   | ✅ 发生   | ✅ 发生   | ❌ 防止 |
| 死锁风险   | 低       | 中       | 高       | 最高   |

## 五、实际案例分析

### 案例1：电商库存超卖
```sql
-- 错误实现（有并发问题）
CREATE PROCEDURE place_order(product_id INT, quantity INT)
BEGIN
    DECLARE current_stock INT;
    
    START TRANSACTION;
    -- 1. 查询库存
    SELECT stock INTO current_stock 
    FROM products WHERE id = product_id;
    
    -- 2. 检查库存
    IF current_stock >= quantity THEN
        -- 3. 更新库存
        UPDATE products 
        SET stock = current_stock - quantity 
        WHERE id = product_id;
        
        -- 4. 创建订单
        INSERT INTO orders (...) VALUES (...);
        COMMIT;
    ELSE
        ROLLBACK;
    END IF;
END;
-- 问题：并发时可能超卖，出现负库存
```

### 案例2：银行转账丢失更新
```sql
-- 问题代码
BEGIN TRANSACTION;

-- 读取双方余额
SELECT balance INTO @from_balance FROM accounts WHERE id = @from_id;
SELECT balance INTO @to_balance FROM accounts WHERE id = @to_id;

-- 验证和计算（应用层）
SET @new_from_balance = @from_balance - @amount;
SET @new_to_balance = @to_balance + @amount;

-- 更新（可能丢失更新）
UPDATE accounts SET balance = @new_from_balance WHERE id = @from_id;
UPDATE accounts SET balance = @new_to_balance WHERE id = @to_id;

COMMIT;
```

## 六、解决方案总结

### 1. **隔离级别选择**
- 大多数场景：**读已提交**
- 财务系统：**可重复读**或**串行化**
- 报表查询：**读未提交**（允许脏读但性能好）

### 2. **锁策略**
```sql
-- 悲观锁
SELECT ... FOR UPDATE;  -- 用于高冲突场景

-- 乐观锁
UPDATE ... WHERE version = @old_version;

-- 原子操作
UPDATE ... SET balance = balance - 100 WHERE ...;
```

### 3. **设计模式**
- **CAS操作**：Compare and Swap
- **幂等操作**：支持重试
- **队列处理**：将并发转为顺序
- **版本控制**：乐观锁实现

### 4. **监控和预防**
```sql
-- 监控长时间运行事务
SELECT * FROM information_schema.innodb_trx 
WHERE TIME_TO_SEC(TIMEDIFF(NOW(), trx_started)) > 60;

-- 监控锁等待
SHOW ENGINE INNODB STATUS;

-- 死锁日志
SHOW VARIABLES LIKE 'innodb_print_all_deadlocks';
```

## 七、现代数据库的增强方案

### 1. **MVCC（多版本并发控制）**
- PostgreSQL、MySQL InnoDB使用
- 读不阻塞写，写不阻塞读
- 通过版本快照避免部分并发问题

### 2. **SSI（可串行化快照隔离）**
- PostgreSQL 9.1+ 的串行化实现
- 检测写偏斜并回滚
- 性能比传统串行化更好

### 3. **乐观并发控制**
```sql
-- SQL Server的乐观并发
BEGIN TRANSACTION;
-- 使用行版本
UPDATE table 
SET data = @new_data
WHERE id = @id 
  AND last_update = @original_last_update;
-- 检查@@ROWCOUNT
COMMIT;
```

## 八、最佳实践建议

1. **事务要短小**：尽快提交释放锁
2. **访问顺序一致**：避免死锁（按固定顺序访问表）
3. **合理设置超时**：
   ```sql
   SET innodb_lock_wait_timeout = 5;
   SET max_execution_time = 10000;
   ```
4. **使用重试机制**：
   ```python
   for attempt in range(3):
       try:
           execute_transaction()
           break
       except DeadlockError:
           sleep(2 ** attempt)  # 指数退避
           continue
   ```
5. **监控和告警**：
   - 长时间运行事务
   - 死锁频率
   - 锁等待时间

