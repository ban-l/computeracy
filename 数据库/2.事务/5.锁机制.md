# 锁机制

**数据库锁机制**——保证数据一致性和事务隔离的核心技术。

## 一、锁的基本概念

### 锁的本质
**锁**是数据库管理系统控制并发访问的同步机制，用于：
- 保证事务的**隔离性**
- 防止数据不一致
- 协调多个事务对资源的访问顺序

### 锁的基本工作流程
```sql
-- 示例：事务A获取锁
BEGIN;
-- 1. 请求锁
-- 2. 如果锁可用，获取锁并继续
-- 3. 如果锁被占用，等待或超时
UPDATE accounts SET balance = balance - 100 WHERE id = 1;

-- 事务B尝试访问同一资源
BEGIN;
UPDATE accounts SET balance = balance + 100 WHERE id = 1;
-- 等待事务A释放锁...
```

## 二、锁的类型（从不同维度分类）

### 1. **按锁的互斥程度分**

#### **共享锁（S锁，读锁）**
```sql
-- 多个事务可以同时持有共享锁
-- 用于读操作
SELECT * FROM employees WHERE department = 'IT' LOCK IN SHARE MODE;
-- 或
SELECT * FROM employees WITH(SHARELOCK) WHERE department = 'IT';
```

**特性**：

- 允许多个事务同时读取同一数据
- 阻止其他事务获取排他锁
- 不阻止其他事务获取共享锁

#### **排他锁（X锁，写锁）**
```sql
-- 一次只能有一个事务持有排他锁
-- 用于写操作
UPDATE employees SET salary = salary * 1.1 WHERE department = 'IT';
-- 或显式获取
SELECT * FROM employees FOR UPDATE;
```

**特性**：
- 阻止其他事务获取任何类型的锁
- 保证写操作的独占性

### 2. **按锁定粒度分**

#### **表级锁**
```sql
-- MySQL MyISAM引擎使用表锁
LOCK TABLES orders WRITE, order_items READ;
-- 执行操作...
UNLOCK TABLES;

-- SQL Server表级提示
SELECT * FROM large_table WITH (TABLOCKX); -- 排他表锁
```

**优缺点**：
- ✅ 开销小，加锁快
- ❌ 并发度低，容易阻塞

#### **行级锁**
```sql
-- InnoDB默认行级锁
BEGIN;
-- 只锁定满足条件的行
UPDATE orders SET status = 'shipped' WHERE order_id = 1001;
-- 其他事务可以修改 order_id ≠ 1001 的行
COMMIT;
```

**优缺点**：
- ✅ 并发度高，冲突少
- ❌ 开销大，管理复杂

#### **意向锁（Intention Locks）**
```sql
-- 表级锁，表示打算在更低粒度上加锁
-- IS锁：打算加S锁
-- IX锁：打算加X锁
-- SIX锁：S锁 + IX锁（共享意向排他锁）
```

### 3. **按锁的模式分**

#### **乐观锁**
```sql
-- 不真正加锁，通过版本控制实现
UPDATE products 
SET stock = stock - 1, 
    version = version + 1
WHERE id = 1 AND version = @old_version;

-- 检查是否成功
IF @@ROWCOUNT = 0
    -- 版本冲突，重试或报错
```

#### **悲观锁**
```sql
-- 默认认为冲突会发生，先加锁
BEGIN;
-- 悲观锁方式
SELECT * FROM products WHERE id = 1 FOR UPDATE;
-- 安全地更新
UPDATE products SET stock = stock - 1 WHERE id = 1;
COMMIT;
```

## 三、MySQL InnoDB锁机制详解

### 1. **记录锁（Record Locks）**
```sql
-- 锁定单条记录
BEGIN;
-- 对id=1的记录加X锁
SELECT * FROM users WHERE id = 1 FOR UPDATE;
-- 只有id=1的行被锁定，其他行可正常访问
```

### 2. **间隙锁（Gap Locks）**
```sql
-- 锁定一个范围，但不包括记录本身
-- 表结构：id(1,3,5,7,9)

BEGIN;
-- 锁定 (5,7) 这个区间
SELECT * FROM users WHERE id = 6 FOR UPDATE;
-- 阻止其他事务在5和7之间插入数据
-- 可以插入id=4，不能插入id=6
```

### 3. **临键锁（Next-Key Locks）**
```sql
-- 记录锁 + 间隙锁的组合
-- InnoDB默认的行锁算法

-- 锁定范围：(-∞,1], (1,3], (3,5], ...
BEGIN;
-- 锁定 (3,5] 这个区间
SELECT * FROM users WHERE id > 3 AND id < 6 FOR UPDATE;
-- 阻止插入id=4,5，也锁定已有id=5的记录
```

### 4. **插入意向锁（Insert Intention Locks）**
```sql
-- 特殊的间隙锁，表示打算插入
-- 事务A
BEGIN;
-- 锁定间隙(5,7)
SELECT * FROM users WHERE id = 6 FOR UPDATE;

-- 事务B
BEGIN;
-- 尝试在(5,7)间插入，获取插入意向锁
INSERT INTO users (id) VALUES (6); -- 被阻塞
```

### 5. **自增锁（AUTO-INC Locks）**
```sql
-- 插入自增列时的特殊表锁
-- 三种模式：
-- 0: 传统模式（语句结束释放）
-- 1: 连续模式（默认，事务结束释放）
-- 2: 交错模式（最高并发）

-- 查看当前模式
SHOW VARIABLES LIKE 'innodb_autoinc_lock_mode';
```

## 四、锁的兼容性矩阵

| 请求锁 \ 持有锁 | 无锁 | S锁  | X锁  | IS锁 | IX锁 | SIX锁 |
| --------------- | ---- | ---- | ---- | ---- | ---- | ----- |
| S锁(共享)       | 允许 | 允许 | 拒绝 | 允许 | 拒绝 | 拒绝  |
| X锁(排他)       | 允许 | 拒绝 | 拒绝 | 拒绝 | 拒绝 | 拒绝  |
| IS锁(意向共享)  | 允许 | 允许 | 拒绝 | 允许 | 允许 | 允许  |
| IX锁(意向排他)  | 允许 | 拒绝 | 拒绝 | 允许 | 允许 | 拒绝  |
| SIX锁           | 允许 | 拒绝 | 拒绝 | 允许 | 拒绝 | 拒绝  |

## 五、锁等待与死锁

### 1. **锁等待**
```sql
-- 事务A持有锁
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;

-- 事务B等待锁
BEGIN;
UPDATE accounts SET balance = balance + 100 WHERE id = 1;
-- 被阻塞，等待事务A释放锁

-- 设置锁等待超时
SET innodb_lock_wait_timeout = 5; -- 5秒超时
```

### 2. **死锁产生与解决**
```sql
-- 死锁示例
-- 事务A
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
-- 持有id=1的锁

-- 事务B
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 2;
-- 持有id=2的锁

-- 事务A尝试获取id=2的锁
UPDATE accounts SET balance = balance + 100 WHERE id = 2; -- 等待

-- 事务B尝试获取id=1的锁  
UPDATE accounts SET balance = balance + 100 WHERE id = 1; -- 等待
-- 死锁形成！
```

**死锁检测**：
```sql
-- MySQL死锁信息
SHOW ENGINE INNODB STATUS\G
-- 查看 LATEST DETECTED DEADLOCK 部分

-- 启用详细死锁日志
SET GLOBAL innodb_print_all_deadlocks = ON;
```

**死锁处理策略**：
1. **预防**：
```sql
-- 按固定顺序访问表
-- 所有事务都按 id 顺序访问 accounts 表

-- 使用较低的隔离级别
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 使用乐观锁
UPDATE table SET col = new_val WHERE id = 1 AND version = old_version;
```

2. **检测与恢复**：
```sql
-- 数据库自动检测死锁
-- 选择"牺牲者"回滚（基于事务权重）
-- 牺牲者收到错误：ERROR 1213 (40001): Deadlock found
```

## 六、MySQL锁监控

```sql
-- 查看当前所有事务
SELECT * FROM information_schema.INNODB_TRX;

-- 查看锁等待
SELECT * FROM information_schema.INNODB_LOCK_WAITS;

-- 查看当前持有的锁
SELECT * FROM information_schema.INNODB_LOCKS;

-- 查看锁等待关系图
SELECT 
    r.trx_id AS waiting_trx_id,
    r.trx_mysql_thread_id AS waiting_thread,
    b.trx_id AS blocking_trx_id,
    b.trx_mysql_thread_id AS blocking_thread
FROM information_schema.INNODB_LOCK_WAITS w
JOIN information_schema.INNODB_TRX b ON b.trx_id = w.blocking_trx_id
JOIN information_schema.INNODB_TRX r ON r.trx_id = w.requesting_trx_id;
```

## 七、锁优化策略

1. **减少锁竞争**

2. **合理使用锁提示**

3. **索引优化减少锁**

4. **锁升级管理**

## 八、高级锁模式

### 1. **多粒度锁（Hierarchical Locking）**

```
数据库 → 表空间 → 表 → 页 → 行
```

### 2. **两阶段锁协议（2PL）**
```sql
-- 第一阶段：增长阶段（只获取锁，不释放）
BEGIN;
-- 获取锁1
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
-- 获取锁2  
SELECT * FROM accounts WHERE id = 2 FOR UPDATE;
-- 继续获取锁...

-- 第二阶段：缩减阶段（只释放锁，不获取）
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT; -- 释放所有锁
```

### 3. **严格两阶段锁（Strict 2PL）**
```sql
-- 所有锁都在事务结束时释放
BEGIN;
-- 获取锁
SELECT * FROM table FOR UPDATE;
-- 操作...
-- 事务结束前不释放任何锁
COMMIT; -- 所有锁同时释放
```

### 2. **Redis分布式锁**
## 九、实战案例

### 案例1：高并发秒杀系统锁设计
```sql
-- 方案1：悲观锁（可能死锁）
BEGIN;
SELECT stock FROM products WHERE id = 1001 FOR UPDATE;
IF stock > 0 THEN
    UPDATE products SET stock = stock - 1 WHERE id = 1001;
    INSERT INTO orders (...) VALUES (...);
END IF;
COMMIT;

-- 方案2：乐观锁（推荐）
UPDATE products 
SET stock = stock - 1,
    version = version + 1
WHERE id = 1001 
  AND stock > 0
  AND version = @old_version;

-- 方案3：原子操作（最优）
UPDATE products 
SET stock = CASE 
    WHEN stock > 0 THEN stock - 1 
    ELSE stock 
END
WHERE id = 1001;

-- 检查是否成功
IF ROW_COUNT() > 0 THEN
    -- 创建订单
END IF;
```

### 案例2：防止重复提交
```sql
-- 使用唯一约束 + 行锁
BEGIN;
-- 先检查是否存在（使用锁防止并发插入）
SELECT * FROM submissions 
WHERE user_id = 123 AND assignment_id = 456 
FOR UPDATE;

-- 如果没有记录，则插入
INSERT INTO submissions (user_id, assignment_id, content)
SELECT 123, 456, '作业内容'
FROM dual
WHERE NOT EXISTS (
    SELECT 1 FROM submissions 
    WHERE user_id = 123 AND assignment_id = 456
);

COMMIT;
```

### 案例3：队列处理
```sql
-- 使用SKIP LOCKED处理任务队列
BEGIN;
-- 获取下一个待处理任务
SELECT * FROM task_queue
WHERE status = 'PENDING'
ORDER BY priority DESC, created_at ASC
FOR UPDATE SKIP LOCKED
LIMIT 1;

-- 标记为处理中
UPDATE task_queue 
SET status = 'PROCESSING', 
    started_at = NOW(),
    worker_id = @worker_id
WHERE id = @task_id;

COMMIT;

-- 处理任务...

-- 标记为完成
UPDATE task_queue 
SET status = 'COMPLETED', 
    finished_at = NOW()
WHERE id = @task_id;
```

## 十、最佳实践总结

1. **最小化原则**：锁的粒度尽量小，时间尽量短
2. **顺序访问**：按固定顺序访问资源避免死锁
3. **索引优化**：确保查询使用索引减少锁范围
4. **监控告警**：建立锁等待和死锁监控
5. **超时设置**：合理设置锁等待超时时间
6. **测试验证**：压力测试验证锁机制
7. **文档记录**：记录关键业务场景的锁策略

## 十一、常见问题排查

### Q1：为什么我的查询被阻塞？
```sql
-- 排查步骤：
-- 1. 查看当前阻塞链
-- 2. 分析被阻塞和阻塞的SQL
-- 3. 检查事务隔离级别
-- 4. 检查锁等待超时设置
-- 5. 分析索引使用情况
```

### Q2：如何避免死锁？
```sql
-- 解决方案：
-- 1. 使用较低的隔离级别
-- 2. 按固定顺序访问表
-- 3. 使用乐观锁
-- 4. 减少事务时间
-- 5. 使用死锁重试机制
```

### Q3：锁升级是好是坏？
```
好处：减少锁管理开销
坏处：降低并发度

决策依据：
- 大批量更新：允许锁升级
- 高并发OLTP：阻止锁升级
- 混合负载：根据时段调整
```
