# MVCC

## 一、MVCC概念

**MVCC**（Multi-Version Concurrency Control），即**多版本并发控制**，是现代数据库（如 MySQL 的 InnoDB 引擎、PostgreSQL、Oracle 等）中用于提高并发性能的核心技术。

------

### 1. 核心概念：MVCC 是什么？

简单来说，MVCC 是一种**为了避免在使用锁的情况下进行并发访问**的机制。

在传统的数据库锁机制（悲观锁）中，如果一个人正在写数据（修改），其他人想读数据必须等待，反之亦然。这虽然保证了数据安全，但效率极低。

MVCC 的做法是：**保留数据在某个时间点的“快照”（Snapshot）**。这意味着：

- **写操作**（Update/Delete）时，不会直接覆盖旧数据，而是生成一个新的版本。
- **读操作**（Select）时，数据库会根据当前的事务隔离级别，判断你应该看到哪个版本的数据。

**一句话总结：** MVCC 让数据库实现了**“读不阻塞写，写不阻塞读”**，极大地提升了并发性能。

------

### 2. 通俗类比：版本控制系统

想象你在和同事协作编辑一份文档：

1. **没有 MVCC（传统锁）：** 就像你在编辑一个本地 Excel 文件。当你打开文件修改时，文件被锁定，你的同事想看只能等你保存并关闭后才能打开。这效率很低。
2. **拥有 MVCC：** 就像使用 **Git** 或 **Google Docs**。
   - 当你正在修改第 10 行时，你的同事依然可以查看文档的**旧版本**（快照）。
   - 他看到的，是你修改之前的内容，不会受到你正在输入的干扰。
   - 当你提交（Commit）后，系统会生成一个新的版本，之后的访问者才能看到你的修改。

------

### 3. 技术原理：它是如何工作的？（以 MySQL InnoDB 为例）

InnoDB 实现 MVCC 主要依赖于三个隐式字段、Undo Log（回滚日志）和 Read View（读视图）。

#### A. 隐式字段

数据库在每一行记录中，除了你定义的列，还偷偷维护了几个隐藏列，最重要的两个是：

- **TRX_ID**：最近一次修改该行数据的**事务 ID**。
- **ROLL_PTR**：**回滚指针**，指向这条记录的上一个版本（存储在 Undo Log 中）。

#### B. Undo Log (版本链)

当你要修改一行数据时，数据库不会直接删掉旧数据，而是把旧数据拷贝到 **Undo Log** 中，并通过 `ROLL_PTR` 像链表一样把新旧数据串起来。

> **结果：** 形成了一条“版本链”，最新的在表里，旧的在日志里。

#### C. Read View (读视图 - 可见性判断)

当一个事务发起查询（Select）时，数据库会生成一个 **Read View**。你可以把它理解为一个“快照窗口”。它通过一套算法（比较事务 ID）来判断：

- 当前这条记录的最新版本，我能看吗？（是否是未提交的事务修改的？）
- 如果不能看，顺着版本链往下找，直到找到一个我能看到的旧版本为止。

------

### 4. MVCC 解决了什么痛点？

在数据库的并发控制中，主要有三种冲突：

1. **写-写冲突**：必须加锁解决（MVCC 解决不了这个，必须排队）。
2. **读-写冲突**：一个在读，一个在写。
3. **读-读冲突**：不需要并发控制。

**MVCC 最大的功劳就是解决了“读-写冲突”：**

- 它让**读操作**（快照读）完全不用加锁。
- 它让数据库在**Read Committed（读已提交）**和**Repeatable Read（可重复读）**这两种隔离级别下，依然保持极高的吞吐量。

------

### 总结

**MVCC** 就是一种利用**多版本**来避免**读写锁竞争**的策略。它通过维护数据的历史版本，保证了事务在读取数据时，能够看到一致性的快照，而无需等待正在修改该数据的其他事务释放锁。

------

## 二、Read View

如果说 **Undo Log** 是数据的“历史档案馆”（保存了数据的旧版本），那么 **Read View** 就是每一位访客手中的“**参观通行证**”。

它决定了当你的事务在查询数据时，面对版本链里的那一堆新老数据，**到底哪一个版本才是你应该看到的**。

------

### 1. 什么是 Read View？

Read View 是事务进行**快照读**（Snapshot Read，即普通 SELECT）操作时产生的一个读视图。

你可以把它想象成一个**“当前时刻的事务状态快照”**。当你的事务启动查询时，数据库会拍一张照片，记录下**此时此刻**系统里：

- 谁还在忙着没提交（活跃事务）？
- 谁已经干完活了（已提交事务）？
- 下一个新来的事务 ID 应该是多少？

拿着这张照片（Read View），你去比对数据行上的事务 ID，就能判断可见性。

------

### 2. Read View 的 4 个核心字段（解剖图）

在 MySQL InnoDB 源码中，Read View 主要包含以下 4 个关键字段，理解了它们就理解了判断逻辑：

| **字段名**         | **含义**                                   | **通俗理解**                                                 |
| ------------------ | ------------------------------------------ | ------------------------------------------------------------ |
| **m_ids**          | 当前系统中**活跃**（未提交）的事务 ID 列表 | “黑名单”：这些人还没干完活，他们改的数据你不能看。           |
| **min_trx_id**     | `m_ids` 中最小的事务 ID                    | “水位线下限”：比这个 ID 小的，说明早就提交了，随便看。       |
| **max_trx_id**     | 系统应该分配给**下一个**事务的 ID          | “水位线元老”：注意，这是**预分配 ID**，不是当前最大 ID。比这个 ID 大的，说明是你查询之后才开启的事务，统统不能看。 |
| **creator_trx_id** | 生成该 Read View 的事务 ID                 | “我自己”：我自己改的数据，我自己当然能看。                   |

------

### 3. 可见性判断算法（核心逻辑）

当你的事务去读取一行数据时，会拿到这行数据的隐藏列 `trx_id`（最后一次修改这行数据的事务 ID），然后拿这个 `trx_id` 去跟你的 **Read View** 进行比对。

比对规则如下（请代入“我”就是当前查询事务）：

1. **是“我”自己改的吗？**
   - 如果 `trx_id == creator_trx_id`：
   - **结果**：**可见**。我自己修改的数据当然看得到。
2. **是“过去”就已经提交的吗？**
   - 如果 `trx_id < min_trx_id`：
   - 说明修改这行数据的事务，在我的 Read View 生成之前就已经提交了。
   - **结果**：**可见**。
3. **是“未来”才发生的吗？**
   - 如果 `trx_id >= max_trx_id`：
   - 说明修改这行数据的事务，是在我生成 Read View 之后才开启的。
   - **结果**：**不可见**。
4. **如果在“中间地带”，需要查成分**
   - 如果 `min_trx_id <= trx_id < max_trx_id`：
   - 这时候需要检查 `trx_id` 是否在 `m_ids`（活跃列表）中？
     - **情况 A：在 `m_ids` 中** → 说明生成 Read View 时，那个事务还没提交（是活跃的）。
       - **结果**：**不可见**。
     - **情况 B：不在 `m_ids` 中** → 说明生成 Read View 时，那个事务已经提交了。
       - **结果**：**可见**。

如果不满足可见性怎么办？

数据库会根据该行的回滚指针（ROLL_PTR），去 Undo Log 里找上一个版本，取出上一个版本的 trx_id，重复上述判断步骤，直到找到一个可见的版本，或者链表结束。

------

### 4. RC 与 RR 的区别：Read View 生成时机

这是面试中的**超高频考点**。既然规则是一样的，为什么 **Read Committed (RC)** 和 **Repeatable Read (RR)** 的表现不一样？

根本原因在于 **Read View 生成的时机不同**。

#### 1. Read Committed (读已提交)

- **机制**：**每次 SELECT 查询时，都会重新生成一个 Read View**。
- **效果**：如果刚才有个事务 A 提交了，我第二次查询时生成了新的 Read View，发现 A 不在“活跃列表”里了，所以我能看到 A 修改的数据。
- **代价**：导致了“不可重复读”现象（同一个事务里两次读取结果不一样）。

#### 2. Repeatable Read (可重复读) - MySQL 默认

- **机制**：**只在事务的第一次 SELECT 查询时生成 Read View，之后复用这个 Read View**。
- **效果**：不管谁提交了、谁修改了，我手里的 Read View 永远是第一次的那张照片。根据照片判断，之前没提交的，现在依然被判定为“不可见”。
- **代价**：保证了数据的一致性视图，解决了“不可重复读”。

------

### 5. 一个具体的例子

假设当前系统里有两个活跃事务，ID 分别是 100 和 200。当前系统下一个要分配的 ID 是 300。

事务 C（ID 300）启动了。

**事务 C 的 Read View:**

- `m_ids`: [100, 200]
- `min_trx_id`: 100
- `max_trx_id`: 301 (注意：是当前最大ID+1)
- `creator_trx_id`: 300

**场景分析：**

1. **事务 100 改了某行数据**：C 拿数据的 `trx_id` (100) 比对。100 在 `m_ids` 列表里。**不可见**。
2. **事务 50 (早就提交了) 改了数据**：C 拿 `trx_id` (50) 比对。50 < `min_trx_id` (100)。**可见**。
3. **事务 400 (后来才开启的) 改了数据**：C 拿 `trx_id` (400) 比对。400 > `max_trx_id` (301)。**不可见**。

------

### 总结

Read View 本质上就是**MVCC 的“可见性裁决者”**。

它通过维护一组事务 ID 集合，结合比较算法，动态地告诉查询操作：“这行数据太新了你不能看，去 Undo Log 找旧的吧”，或者“这行数据是安全的，请享用”。

------

## 三、快照读与当前读

简单来说，这是 MySQL 在不同场景下处理数据读取的**两种完全不同的策略**。

- **快照读**：读的是历史（为了快，不加锁）。
- **当前读**：读的是现在（为了准，必须加锁）。

------

### 1. 快照读 (Snapshot Read)

#### 核心定义

读取的是记录的**可见版本**（可能是历史版本）。它不加锁，完全依赖 MVCC 机制。

#### 触发场景

普通的 `SELECT` 语句（且没有加锁后缀）。

```SQL
SELECT * FROM table WHERE id = 1;
```

#### 原理

- **依赖**：Read View + Undo Log。
- **逻辑**：根据我们刚才讨论的 Read View 算法，去版本链里找“我能看到的那个版本”。
- **特点**：
  - **非阻塞**：读写不冲突，性能极高。
  - **一致性**：在“可重复读（RR）”级别下，同一个事务里无论查多少次，看到的数据都是一样的（哪怕别的事务已经提交了修改）。

------

### 2. 当前读 (Current Read)

#### 核心定义

读取的是记录的**最新版本**，并且会对读取的记录**加锁**，保证其他事务不能修改它。

#### 触发场景

除了普通查询，几乎所有涉及“修改”或“显式锁定”的操作都是当前读：

1. `SELECT ... LOCK IN SHARE MODE` (共享锁)
2. `SELECT ... FOR UPDATE` (排他锁)
3. **`UPDATE`** / **`INSERT`** / **`DELETE`** (重点！这些操作在执行前，必须先读取最新数据)

#### 原理

- **依赖**：**锁机制** (Next-Key Lock, Record Lock, Gap Lock)。
- **逻辑**：数据库会直接读取表中最“新鲜”的那一行数据。为了防止我读完之后别人改了，或者防止产生“幻读”，数据库会根据隔离级别加上相应的锁。
- **特点**：
  - **阻塞**：如果别的事务正在改这行数据，当前读会被阻塞，直到对方提交。
  - **实时性**：一定能读到最新的已提交数据。

------

### 3. 一个直观的对比案例

假设表 user 中 id=1 的 age=10。

隔离级别：可重复读 (RR)

| **时间点** | **事务 A (你)**                                              | **事务 B (别人)**                                   | **分析**                                                     |
| ---------- | ------------------------------------------------------------ | --------------------------------------------------- | ------------------------------------------------------------ |
| T1         | 开启事务                                                     | 开启事务                                            |                                                              |
| T2         | `SELECT age FROM user WHERE id=1;`   **结果：10**            |                                                     | **快照读**。生成 Read View。                                 |
| T3         |                                                              | `UPDATE user SET age=20 WHERE id=1;`   **提交事务** | 事务 B 修改并提交了，数据库里最新值是 20。                   |
| T4         | `SELECT age FROM user WHERE id=1;`   **结果：10**            |                                                     | **快照读**。复用 T2 的 Read View，根据 MVCC，B 的修改对 A 不可见。 |
| T5         | `SELECT age FROM user WHERE id=1 FOR UPDATE;`   **结果：20** |                                                     | **当前读**！强制读取最新版本，忽略 Read View，直接拿到 20。  |
| T6         | `UPDATE user SET age=age+1 WHERE id=1;`   **结果：age 变为 21** |                                                     | **当前读**！UPDATE 语句执行时，先读到最新的 20，再加 1，变成 21。 |

> 提示：
>
> 注意看 T6。如果 T6 的 UPDATE 也是走“快照读”（读到 10），那么计算结果就是 11，这就导致了 T3 时 B 的修改（20）被覆盖丢失了。
>
> 所以：写操作必须是当前读，必须基于最新值进行计算。

------

### 4. 总结对比表

| **特性**     | **快照读 (Snapshot Read)**  | **当前读 (Current Read)**                   |
| ------------ | --------------------------- | ------------------------------------------- |
| **侧重点**   | **并发性** (Concurrency)    | **一致性/安全性** (Consistency)             |
| **是否加锁** | 否 (无锁)                   | 是 (行锁、间隙锁等)                         |
| **读取版本** | 可能是旧版本 (历史快照)     | 绝对是最新版本                              |
| **底层机制** | MVCC (Undo Log + Read View) | 锁 (Locking)                                |
| **典型语句** | `SELECT ...`                | `UPDATE`, `DELETE`, `SELECT ... FOR UPDATE` |

------

### 5. 经常被问到的“幻读”陷阱

很多资料说“MySQL 的 RR 级别解决了幻读”，这句话其实**只对了一半**。

- **对于快照读**：MySQL 确实通过 MVCC 彻底解决了幻读。你还没提交，我就当看不见。
- **对于当前读**：MVCC 是失效的。为了防止当前读出现幻读（比如我 `UPDATE` 全表，结果你偷偷插了一条新数据，导致我没更新到），MySQL 必须使用 **Next-Key Lock（临键锁）** 来锁住间隙。

------

## 四、**Next-Key Lock**

如果说 **Read View** 是 MVCC 在“快照读”世界的防线，那么 **Next-Key Lock** 就是 MySQL 在“当前读”世界为了对抗“幻读”而铸造的最强盾牌。

简单来说，**Next-Key Lock 是“行锁”与“间隙锁”的组合体**。它不仅锁住你看到的“那一行数据”，还顺手锁住了这行数据前面的“空隙”，防止别人偷偷塞数据进来。

------

### 1. 核心公式：它是怎么组成的？

在 InnoDB 的可重复读（RR）级别下，默认的加锁单位就是 Next-Key Lock。
$$
Next\text{-}Key \ Lock = Record \ Lock + Gap \ Lock
$$


- **Record Lock（记录锁）**：锁住具体的**一行记录**（比如 `id=10`）。
- **Gap Lock（间隙锁）**：锁住记录之前的**间隙**（比如 `id` 在 5 到 10 之间的空白区域），不包含记录本身。

它的范围特性：

Next-Key Lock 锁住的是一个 左开右闭 的区间 ( ]。

> 例如：表中有一个 `id=10` 的记录。锁住 `(-∞, 10]`，意味着你既不能插入小于 10 的数，也不能修改 `id=10` 这行数据。

------

### 2. 为什么要发明它？（解决幻读）

为了防止**幻读（Phantom Read）**。

场景还原：

假设表里有 id 为 10, 20, 30 的三行数据。

你需要查询 id > 15 的所有记录并加锁：

```SQL
SELECT * FROM table WHERE id > 15 FOR UPDATE;
```

如果只加**行锁**（锁住 20 和 30），坏了！

- 别人此时插入一条 `id=25` 的数据。
- 因为 25 没有被锁住，插入成功。
- 当你再次查询时，突然多出来一条 `25`，这就是“幻读”。

Next-Key Lock 的做法：

它不仅锁住 20 和 30，还会把它们之间的间隙锁死：

- 锁住 `(10, 20]`
- 锁住 `(20, 30]`
- 锁住 `(30, +∞)`

这时候，任何想在 `10` 以后插入数据的操作（比如插入 18, 25, 100）都会被阻塞，彻底杜绝了幻读。

------

### 3. 加锁规则详解

Next-Key Lock 虽然强大，但它不是“死板”的。MySQL 会根据查询情况进行**优化（退化）**，这是面试中的高频考点。

假设表结构：`id` (主键), `age` (普通索引)。数据：`10, 20, 30`。

#### 规则 A：唯一索引的等值查询（退化为行锁）

如果你查的是**主键**或**唯一索引**，且记录**存在**。

- `SELECT * FROM table WHERE id = 20 FOR UPDATE;`
- **动作**：Next-Key Lock `(10, 20]` 会**退化**为 **Record Lock**，只锁 `id=20` 这一行。
- **原因**：唯一性约束保证了不可能再插入一个 `id=20`，所以不需要锁间隙。

#### 规则 B：索引上的等值查询，但记录不存在（退化为间隙锁）

如果你查一个不存在的 ID。

- `SELECT * FROM table WHERE id = 15 FOR UPDATE;`
- **动作**：本来应该锁 `(10, 20]`，但因为 15 不存在，优化为 **Gap Lock** `(10, 20)`。
- **效果**：锁住了 10 到 20 之间的缝隙，防止别人插入 15，但允许别人修改 `id=20` 的行。

#### 规则 C：普通索引的等值查询（不退化）

如果你查的是 `age`（普通索引，可能有重复值）。

- `SELECT * FROM table WHERE age = 20 FOR UPDATE;`
- **动作**：必须严格使用 Next-Key Lock。不仅锁住 `(10, 20]`，而且为了防止你在 20 后面插入新的 20，它还会向右多锁一个间隙，直到下一个不满足条件的记录（比如 30），形成 `(20, 30]` 的 Next-Key Lock 或 Gap Lock。
- **结果**：`age=20` 周围的间隙都被锁死。

------

### 4. 总结图示

你可以把 Next-Key Lock 想象成“**占地盘**”：

| **锁类型**        | **形象比喻**    | **范围示例** | **作用**               |
| ----------------- | --------------- | ------------ | ---------------------- |
| **Record Lock**   | 坐在椅子上的人  | `20`         | 保护自己不被修改       |
| **Gap Lock**      | 椅子之间的过道  | `(10, 20)`   | 防止别人搬把新椅子进来 |
| **Next-Key Lock** | 人 + 左边的过道 | `(10, 20]`   | **全方位保护**         |

------

### 建议

Next-Key Lock 是保证数据一致性的功臣，但它也是**造成死锁（Dead Lock）的头号杀手**。

因为它锁住的范围往往比你想象的要大（尤其是范围查询或普通索引查询时），很容易误伤其他事务。

## 五、MVCC读写操作详解

### 1. **SELECT操作（读）**

```sql
-- 事务A：读操作
BEGIN;
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- 获取快照（事务开始时）
-- 快照内容：活跃事务列表、最小事务ID等

SELECT balance FROM accounts WHERE id = 1;
-- 可见性判断：
-- 1. 查找id=1的最新版本
-- 2. 检查trx_id是否对当前事务可见
-- 3. 如果不可见，沿版本链（undo log）查找旧版本
-- 4. 返回合适版本的数据

-- 此时事务B可以并发更新，不影响本事务的读取
COMMIT;
```

### 2. **UPDATE操作（写）**

```sql
-- 事务A：更新操作
BEGIN;

-- 1. 获取行锁（排他锁）
-- 2. 检查当前行版本是否可见
-- 3. 创建新版本：
--    - 复制当前行到undo log
--    - 修改数据
--    - 设置新行的trx_id为当前事务ID
--    - 设置旧行的xmax为当前事务ID
-- 4. 返回成功

UPDATE accounts SET balance = balance - 100 WHERE id = 1;

-- 此时其他事务：
-- 读事务：看到旧版本（快照读）
-- 写事务：等待行锁释放

COMMIT;
```

### 3. **DELETE操作**

```sql
-- 事务A：删除操作
BEGIN;

-- 1. 获取行锁
-- 2. 设置行的xmax为当前事务ID
-- 3. 不立即物理删除，标记为删除

DELETE FROM accounts WHERE id = 1;

-- 其他事务：
-- 快照读：看不到被删除的行（xmax检查）
-- 当前读：看到行被锁定

COMMIT;
-- 实际删除由VACUUM/清理线程完成
```

### 4. **INSERT操作**

```sql
-- 事务A：插入操作
BEGIN;

-- 1. 创建新行
-- 2. 设置xmin为当前事务ID
-- 3. xmax为0

INSERT INTO accounts (id, balance) VALUES (2, 2000);

-- 其他事务可见性：
-- 已提交：可见（xmin < 快照xmin）
-- 未提交：不可见（xmin在活跃事务列表）

COMMIT;
```

## 六、MVCC的优势与挑战

### 1. **优势**

```sql
-- 1. 高并发读写
-- 读不阻塞写，写不阻塞读
BEGIN;
-- 事务A：读
SELECT * FROM large_table; -- 快照读，不加锁

-- 事务B：写（并发）
UPDATE large_table SET col = 'new'; -- 创建新版本

-- 2. 一致性读
-- 整个事务看到一致的数据快照
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
BEGIN;
SELECT * FROM accounts; -- 快照A
-- 其他事务更新...
SELECT * FROM accounts; -- 仍是快照A

-- 3. 减少锁竞争
-- 不需要读锁，减少死锁概率
```

### 2. **挑战与解决方案**

```sql
-- 挑战1：存储空间增长（版本膨胀）
-- 解决方案：优化VACUUM
-- 调整autovacuum参数
ALTER TABLE accounts SET (
    autovacuum_vacuum_scale_factor = 0.05,
    autovacuum_vacuum_threshold = 1000
);

-- 挑战2：长事务问题
-- 解决方案：监控和限制
-- 设置超时
SET idle_in_transaction_session_timeout = '300s';
SET lock_timeout = '30s';

-- 挑战3：更新冲突
-- 解决方案：乐观锁重试
UPDATE products 
SET stock = stock - 1, 
    version = version + 1
WHERE id = 1 AND version = @old_version;

IF ROW_COUNT() = 0 THEN
    -- 冲突，重试逻辑
END IF;
```

