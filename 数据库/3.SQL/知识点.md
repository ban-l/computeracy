# 知识点

## 1.字符集

- 字符集为字母和符号的集合；
- 编码为某个字符集成员的内部表示；
- 校对字符指定如何比较，主要用于排序和分组。

### latin1/utf8/utf8mb4

- latin1字符集，每一个字符使用1个字节表示（插入中文会报错，因为一个中文至少要2个字节）；
- utf8字符集，每一个字符使用1-3个字节表示（能表示大多数语言，当需要插入中文选utf8字符集）；
- utf8mb4字符集，每一个字符使用1-4个字节表示。

### 校验规则(校对字符)

- 校验规则使⽤utf8_ general_ ci 对select的结果不区分⼤⼩写进行筛选
- 校验规则使⽤utf8_bin 是区分大小写的

### 2.关于 JOIN 的性能与陷阱

**1. "驱动表" (Driving Table) 的选择**
数据库优化器（Optimizer）在执行 JOIN 时，会选择一张表作为“驱动表”（外层循环），另一张作为“被驱动表”（内层循环）。

* **原则**：**小表驱动大表**。
* **解释**：优化器试图先拿数据量小的表进行过滤，拿着过滤后的结果集去大表中查找匹配项。在写 SQL 时，虽然现在的优化器很智能，但理解这一点有助于你通过 `EXPLAIN` 分析执行计划。

**2. 连接条件上的索引**

* **铁律**：用于 `JOIN` 的字段（如 `ON u.id = o.user_id`）**必须**建立索引。
* 如果不建索引，数据库可能被迫使用 "Block Nested-Loop Join" (BNL)，这在内存中进行全表扫描匹配，效率极低。

**3. `ON` 和 `WHERE` 的区别 (在 LEFT JOIN 中)**
这是很多中高级工程师容易混淆的点：

* **`ON`**：在生成临时表时进行过滤。如果是 LEFT JOIN，即使 `ON` 条件不满足，左表的行依然会保留（右侧补 NULL）。
* **`WHERE`**：在临时表生成**之后**进行过滤。如果在这里加条件，LEFT JOIN 往往会退化成 INNER JOIN，因为 `WHERE` 会把 NULL 值过滤掉。

**示例：**

```sql
-- 情况 A：LEFT JOIN 依然生效，查看所有用户，只是只关联特定日期的订单
SELECT * FROM users u LEFT JOIN orders o ON u.id = o.user_id AND o.date = '2023-01-01';

-- 情况 B：LEFT JOIN 失效，效果等同于 INNER JOIN，因为 NULL != '2023-01-01'
SELECT * FROM users u LEFT JOIN orders o ON u.id = o.user_id WHERE o.date = '2023-01-01';
```
