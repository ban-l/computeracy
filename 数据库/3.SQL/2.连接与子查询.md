# 连接与子查询

**连接（JOIN）是处理“横向”的关系（表与表的拼接），而子查询（Subquery）是处理“纵向”或“嵌套”的逻辑（一步步推导结果）。**

## 第一部分：连接查询 (JOIN)

以两个最经典的业务表为例来演示：

* **`users` 表** (左表)：用户基础信息。
* **`orders` 表** (右表)：用户的订单信息（并不是每个用户都有订单）。

### 1. INNER JOIN：内连接 (交集)

这是最常用的连接方式。只返回两个表中**连接字段匹配成功**的行。

* **逻辑**：只有既注册了又下了单的用户才会被查出来。
* **场景**：查询“所有下过单的活跃用户”。

```sql
SELECT u.name, o.order_id
FROM users u
INNER JOIN orders o ON u.id = o.user_id;
```

### 2. LEFT JOIN：左连接 (左侧全集 + 交集)

以左表（`users`）为主表，返回左表所有行。如果右表（`orders`）中没有匹配的记录，则右侧字段显示为 `NULL`。

* **逻辑**：列出所有用户，如果有订单就显示订单号，没订单就留空。
* **场景**：用户列表展示、报表统计（包括未下单用户）。

```sql
SELECT u.name, o.order_id
FROM users u
LEFT JOIN orders o ON u.id = o.user_id;
```

### 3. RIGHT JOIN：右连接 (右侧全集 + 交集)

以右表（`orders`）为主表。

* **提示**：在实际开发中，**极少使用 RIGHT JOIN**。通常我们会习惯性地把主表放在左边（使用 LEFT JOIN），以符合从左到右的阅读逻辑。RIGHT JOIN 往往可以被 LEFT JOIN 替代（只需交换表的位置）。

### 4. FULL OUTER JOIN：全连接 (并集)

返回两个表中所有的行。只要其中一个表存在记录，就会返回。不匹配的地方填 `NULL`。

* **注意**：MySQL 原生不支持 `FULL JOIN`，通常需要通过 `UNION` 来模拟（把 LEFT JOIN 和 RIGHT JOIN 的结果合并）。

```sql
-- MySQL 模拟 FULL JOIN
SELECT u.name, o.order_id FROM users u LEFT JOIN orders o ON u.id = o.user_id
UNION
SELECT u.name, o.order_id FROM users u RIGHT JOIN orders o ON u.id = o.user_id;
```

### 5. CROSS JOIN：笛卡尔积 (全排列)

这是最危险的连接。它不需要连接条件，返回的是左表行数 × 右表行数的结果。

* **后果**：如果表 A 有 1000 行，表 B 有 1000 行，结果就是 1,000,000 行。在生产库误用会导致数据库 CPU 飙升甚至宕机。

### 6. 自连接 (Self-Join)

这是很多人的盲区。当**数据和它层级关系的数据都在同一张表里**时，我们需要“自己连自己”。

* **场景**：员工表 `employee`，其中有一列 `manager_id` 指向同一张表的 `id`。我们要查“员工姓名”和他对应的“经理姓名”。
* **写法**：必须给表起两个不同的别名（比如 `e` 代表员工表，`m` 代表经理表）。

```sql
SELECT 
    e.name AS 员工, 
    m.name AS 经理
FROM employee e              -- 把表看作“员工表”
LEFT JOIN employee m         -- 把同一张表看作“经理表”
    ON e.manager_id = m.id;  -- 员工的经理ID = 经理的ID
```

### 7. ON 与 WHERE 的过滤陷阱 (Expert Insight)

在使用 `LEFT JOIN` 时，过滤条件写在 `ON` 后和写在 `WHERE` 后，结果截然不同。这是导致数据丢失的常见原因。

* **场景**：找出所有用户及其昨天的订单（如果没有订单也要显示用户）。
* **错误写法 (WHERE)**：

```sql
SELECT u.name, o.order_date
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE o.order_date = '2023-10-01'; 
```


> **后果**：这会变成 INNER JOIN！因为 `WHERE` 是在连接生成后才过滤，那些没有订单的用户（order_date 为 NULL）会被 `WHERE` 剔除。


* **正确写法 (ON)**：

```sql
SELECT u.name, o.order_date
FROM users u
LEFT JOIN orders o ON u.id = o.user_id AND o.order_date = '2023-10-01';
```


> **解释**：在连接发生**之前**，先筛选右表。即使右表没数据，左表（用户）依然会被保留。

---

## 第二部分：子查询 (Subqueries)

子查询就是“嵌套在其他 SQL 中的查询”。根据位置和依赖关系，分为两类。

### 1. 标量子查询 vs. 派生表

* **标量子查询 (Scalar)**：子查询返回**单一值**（一行一列）。
* *场景*：查询价格高于“平均价格”的商品。
* `WHERE price > (SELECT AVG(price) FROM products)`


* **派生表 (Derived Table)**：子查询放在 `FROM` 后面，充当一个**临时表**。
* *场景*：这是解决复杂聚合问题的神器。比如，先算出每个部门的平均薪资，再拿这个结果去关联其他表。

```sql
SELECT d.dept_name, temp.avg_salary
FROM departments d
JOIN (
    -- 这是一个派生表，先算出结果，把它当成一张虚拟表 temp
    SELECT dept_id, AVG(salary) as avg_salary 
    FROM employees 
    GROUP BY dept_id
) temp ON d.id = temp.dept_id;
```

### 2. 相关子查询 (Correlated Subquery) —— 性能杀手

这是你需要特别警惕的概念。

* **定义**：子查询内部引用了外部查询的字段。
* **执行逻辑**：外部查询每执行一行，子查询就要执行一次（类似 Java 中的嵌套 `for` 循环）。
* **场景**：查找工资高于**本部门**平均工资的员工。

```sql
SELECT name, salary, dept_id
FROM employees e1
WHERE salary > (
    SELECT AVG(salary) 
    FROM employees e2 
    WHERE e2.dept_id = e1.dept_id  -- 注意这里：内部引用了外部的 e1
);
```

> **建议**：如果数据量大，尽量避免相关子查询，改用 `JOIN` 或窗口函数（Window Functions）来优化。

---

## 第三部分：IN 与 EXISTS 的博弈

在做子查询过滤时，我们经常纠结用 `IN` 还是 `EXISTS`。

| 关键字     | 运作机制                                                     | 最佳场景                                                 |
| ---------- | ------------------------------------------------------------ | -------------------------------------------------------- |
| **IN**     | 先把子查询全部执行完，把结果集缓存，再过滤外部表。           | **子查询结果集很小**，外部表很大时。                     |
| **EXISTS** | 外部表走一行，就去子查询里看一眼“有没有”。一旦找到匹配就停止（不再扫描剩余数据）。 | **子查询表很大**，但外部表较小时（或者两者都有索引时）。 |

**示例 (查询下过订单的用户)**：
如果 `orders` 表有几千万条数据，而 `users` 表很小：

```sql
-- 推荐使用 EXISTS
SELECT * FROM users u
WHERE EXISTS (
    SELECT 1 FROM orders o WHERE o.user_id = u.id
);
```

---

## 总结与实战建议

1. **优先使用 JOIN**：在大多数数据库引擎中，JOIN 的优化做得比子查询好，效率通常更高。
2. **谨慎使用相关子查询**：它是导致查询超时的常见原因。
3. **CTE (公用表表达式)**：如果你发现子查询嵌套太深（多层洋葱皮），建议使用 `WITH AS` 语法（CTE），这会让代码可读性提升十倍。