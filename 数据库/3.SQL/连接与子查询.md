# 连接与子查询

**连接（JOIN）是处理“横向”的关系（表与表的拼接），而子查询（Subquery）是处理“纵向”或“嵌套”的逻辑（一步步推导结果）。**

---

## 第一部分：连接查询 (JOIN)

* `INNER JOIN`: **交集**。两张表都有匹配数据才返回。
* `LEFT JOIN`: **左侧全集**。左表所有数据都返回，右表没匹配的显示 `NULL`。
* `RIGHT JOIN`: **右侧全集**。
* `FULL JOIN`: **并集**（MySQL不直接支持，需用 `UNION` 模拟）。

上述为基本的连接，但在实际复杂的业务（比如你的黑名单或通话记录分析）中，以下两种场景非常关键：

### 1. 自连接 (Self-Join)

这是很多人的盲区。当**数据和它层级关系的数据都在同一张表里**时，我们需要“自己连自己”。

* **场景**：员工表 `employee`，其中有一列 `manager_id` 指向同一张表的 `id`。我们要查“员工姓名”和他对应的“经理姓名”。
* **写法**：必须给表起两个不同的别名（比如 `e` 代表员工表，`m` 代表经理表）。

```sql
SELECT 
    e.name AS 员工, 
    m.name AS 经理
FROM employee e              -- 把表看作“员工表”
LEFT JOIN employee m         -- 把同一张表看作“经理表”
    ON e.manager_id = m.id;  -- 员工的经理ID = 经理的ID
```

### 2. ON 与 WHERE 的过滤陷阱 (Expert Insight)

在使用 `LEFT JOIN` 时，过滤条件写在 `ON` 后和写在 `WHERE` 后，结果截然不同。这是导致数据丢失的常见原因。

* **场景**：找出所有用户及其昨天的订单（如果没有订单也要显示用户）。
* **错误写法 (WHERE)**：

```sql
SELECT u.name, o.order_date
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE o.order_date = '2023-10-01'; 
```


> **后果**：这会变成 INNER JOIN！因为 `WHERE` 是在连接生成后才过滤，那些没有订单的用户（order_date 为 NULL）会被 `WHERE` 剔除。


* **正确写法 (ON)**：

```sql
SELECT u.name, o.order_date
FROM users u
LEFT JOIN orders o ON u.id = o.user_id AND o.order_date = '2023-10-01';
```


> **解释**：在连接发生**之前**，先筛选右表。即使右表没数据，左表（用户）依然会被保留。

---

## 第二部分：子查询 (Subqueries)

子查询就是“嵌套在其他 SQL 中的查询”。根据位置和依赖关系，分为两类。

### 1. 标量子查询 vs. 派生表

* **标量子查询 (Scalar)**：子查询返回**单一值**（一行一列）。
* *场景*：查询价格高于“平均价格”的商品。
* `WHERE price > (SELECT AVG(price) FROM products)`


* **派生表 (Derived Table)**：子查询放在 `FROM` 后面，充当一个**临时表**。
* *场景*：这是解决复杂聚合问题的神器。比如，先算出每个部门的平均薪资，再拿这个结果去关联其他表。

```sql
SELECT d.dept_name, temp.avg_salary
FROM departments d
JOIN (
    -- 这是一个派生表，先算出结果，把它当成一张虚拟表 temp
    SELECT dept_id, AVG(salary) as avg_salary 
    FROM employees 
    GROUP BY dept_id
) temp ON d.id = temp.dept_id;
```

### 2. 相关子查询 (Correlated Subquery) —— 性能杀手

这是你需要特别警惕的概念。

* **定义**：子查询内部引用了外部查询的字段。
* **执行逻辑**：外部查询每执行一行，子查询就要执行一次（类似 Java 中的嵌套 `for` 循环）。
* **场景**：查找工资高于**本部门**平均工资的员工。

```sql
SELECT name, salary, dept_id
FROM employees e1
WHERE salary > (
    SELECT AVG(salary) 
    FROM employees e2 
    WHERE e2.dept_id = e1.dept_id  -- 注意这里：内部引用了外部的 e1
);
```

> **建议**：如果数据量大，尽量避免相关子查询，改用 `JOIN` 或窗口函数（Window Functions）来优化。

---

## 第三部分：IN 与 EXISTS 的博弈

在做子查询过滤时，我们经常纠结用 `IN` 还是 `EXISTS`。

| 关键字     | 运作机制                                                     | 最佳场景                                                 |
| ---------- | ------------------------------------------------------------ | -------------------------------------------------------- |
| **IN**     | 先把子查询全部执行完，把结果集缓存，再过滤外部表。           | **子查询结果集很小**，外部表很大时。                     |
| **EXISTS** | 外部表走一行，就去子查询里看一眼“有没有”。一旦找到匹配就停止（不再扫描剩余数据）。 | **子查询表很大**，但外部表较小时（或者两者都有索引时）。 |

**示例 (查询下过订单的用户)**：
如果 `orders` 表有几千万条数据，而 `users` 表很小：

```sql
-- 推荐使用 EXISTS
SELECT * FROM users u
WHERE EXISTS (
    SELECT 1 FROM orders o WHERE o.user_id = u.id
);
```

---

## 总结与实战建议

1. **优先使用 JOIN**：在大多数数据库引擎中，JOIN 的优化做得比子查询好，效率通常更高。
2. **谨慎使用相关子查询**：它是导致查询超时的常见原因。
3. **CTE (公用表表达式)**：如果你发现子查询嵌套太深（多层洋葱皮），建议使用 `WITH AS` 语法（CTE），这会让代码可读性提升十倍。